<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <meta name="theme-color" content="#020205">
    <meta name="format-detection" content="telephone=no">
    <title>UNFAIR ODYSSEY PRO: ULTIMATE EDITION</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap');

        :root {
            --primary: #00f2ff;
            --secondary: #7000ff;
            --danger: #ff0055;
            --warning: #ffaa00;
            --success: #00ff88;
            --waifu: #ff85a1;
            --bg: #020205;
            --neon-glow: 0 0 5px var(--primary), 0 0 10px var(--primary), 0 0 20px var(--primary);
        }

        * { box-sizing: border-box; }
        
        body, html { 
            margin: 0; 
            padding: 0; 
            background: var(--bg); 
            color: white; 
            font-family: 'Rajdhani', sans-serif; 
            overflow: hidden; 
            height: 100vh; 
            width: 100vw;
            position: fixed;
            display: flex; 
            align-items: center; 
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            touch-action: none;
            overscroll-behavior: none;
        }

        /* Prevent zoom on mobile */
        input, textarea, select, button {
            font-size: 16px !important;
            -webkit-appearance: none;
        }

        /* Force landscape orientation hint */
        @media screen and (max-width: 768px) {
            html {
                transform: rotate(-90deg);
                transform-origin: left top;
                width: 100vh;
                height: 100vw;
                overflow-x: hidden;
                position: absolute;
                top: 100%;
                left: 0;
            }
        }

        /* Better approach - show rotate message in portrait */
        @media screen and (orientation: portrait) and (max-width: 768px) {
            html {
                transform: none;
                width: 100vw;
                height: 100vh;
                position: relative;
                top: auto;
                left: auto;
            }
        }

        /* Scanline Effect */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 9999;
            animation: scanline 8s linear infinite;
        }

        @keyframes scanline {
            0% { transform: translateY(0); }
            100% { transform: translateY(10px); }
        }

        /* Game Container */
        #stage {
            position: relative; 
            width: 1200px; 
            height: 650px;
            background: #050508; 
            border: 2px solid var(--primary);
            overflow: hidden; 
            box-shadow: 
                0 0 50px rgba(0, 242, 255, 0.3),
                inset 0 0 100px rgba(0, 0, 0, 0.8);
            border-radius: 8px;
        }

        /* Mobile Landscape - Full Screen */
        @media screen and (max-width: 926px) and (orientation: landscape) {
            #stage {
                width: 100vw !important;
                height: 100vh !important;
                border-radius: 0 !important;
                border: none !important;
                max-width: 100vw !important;
                max-height: 100vh !important;
            }

            body, html {
                width: 100vw !important;
                height: 100vh !important;
            }

            .mobile-controls {
                display: flex !important;
            }

            .hud {
                font-size: 11px !important;
                gap: 8px !important;
                top: 10px !important;
                left: 10px !important;
                right: 10px !important;
            }

            .hud-item {
                padding: 6px 12px !important;
            }

            .pause-btn {
                top: 10px !important;
                right: 10px !important;
                width: 40px !important;
                height: 40px !important;
                font-size: 18px !important;
            }
        }

        /* Tablet landscape */
        @media screen and (min-width: 927px) and (max-width: 1250px) and (orientation: landscape) {
            #stage {
                width: 95vw !important;
                height: 90vh !important;
            }
        }

        /* Parallax Layers */
        .layer { 
            position: absolute; 
            inset: 0; 
            pointer-events: none; 
        }

        .sky { 
            background: radial-gradient(ellipse at bottom, #1a1a3e 0%, #0a0a1e 50%, #020205 100%);
        }

        .stars { 
            background-image: 
                radial-gradient(2px 2px at 20px 30px, white, transparent),
                radial-gradient(2px 2px at 60px 70px, white, transparent),
                radial-gradient(1px 1px at 50px 50px, white, transparent),
                radial-gradient(1px 1px at 130px 80px, white, transparent),
                radial-gradient(2px 2px at 90px 10px, white, transparent);
            background-repeat: repeat;
            background-size: 200px 200px;
            animation: starsMove 120s linear infinite;
            opacity: 0.6;
        }

        @keyframes starsMove {
            from { transform: translateX(0); }
            to { transform: translateX(-200px); }
        }

        /* Nebula effect */
        .nebula {
            background: 
                radial-gradient(ellipse at 20% 50%, rgba(112, 0, 255, 0.3) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 70%, rgba(0, 242, 255, 0.2) 0%, transparent 50%);
            animation: nebulaShift 20s ease-in-out infinite alternate;
        }

        @keyframes nebulaShift {
            0% { opacity: 0.3; transform: scale(1); }
            100% { opacity: 0.5; transform: scale(1.1); }
        }

        /* Mountains layers */
        .mountains-far {
            bottom: 80px;
            height: 250px;
            background: linear-gradient(to bottom, transparent 0%, rgba(0, 242, 255, 0.08) 100%);
            clip-path: polygon(
                0% 70%, 10% 50%, 20% 60%, 30% 40%, 40% 55%, 
                50% 35%, 60% 50%, 70% 30%, 80% 45%, 90% 35%, 100% 50%, 
                100% 100%, 0% 100%
            );
        }

        .mountains-near {
            bottom: 80px;
            height: 180px;
            background: linear-gradient(to bottom, transparent 0%, rgba(112, 0, 255, 0.15) 100%);
            clip-path: polygon(
                0% 60%, 15% 45%, 25% 55%, 35% 35%, 45% 50%, 
                55% 30%, 65% 45%, 75% 25%, 85% 40%, 95% 30%, 100% 45%, 
                100% 100%, 0% 100%
            );
        }

        /* Dynamic Content Layer */
        #traps-layer,
        #particles-layer,
        #warnings-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            transition: transform 0.05s linear;
            will-change: transform;
        }

        #floor {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 80px;
            background: 
                linear-gradient(180deg, #0f172a 0%, #020617 50%, #000000 100%),
                repeating-linear-gradient(90deg, transparent, transparent 49px, var(--primary) 49px, var(--primary) 50px),
                repeating-linear-gradient(0deg, transparent, transparent 49px, var(--primary) 49px, var(--primary) 50px);
            background-size: 100% 100%, 50px 50px, 50px 50px;
            border-top: 3px solid var(--primary);
            box-shadow: 0 -5px 30px rgba(0, 242, 255, 0.3);
            z-index: 100;
            animation: gridMove 2s linear infinite;
            transition: transform 0.05s linear;
            will-change: transform;
        }

        @keyframes gridMove {
            0% { background-position: 0 0, 0 0, 0 0; }
            100% { background-position: 0 0, -50px 0, 0 -50px; }
        }

        /* Player - Advanced Stickman */
        #player {
            position: absolute;
            width: 35px;
            height: 60px;
            bottom: 80px;
            left: 120px;
            z-index: 110;
            will-change: transform, bottom, left;
            filter: drop-shadow(0 0 10px var(--primary));
            transition: filter 0.3s, left 0.05s linear;
        }

        #player.invincible {
            animation: invincibleBlink 0.2s infinite;
        }

        @keyframes invincibleBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .head {
            width: 20px;
            height: 20px;
            background: radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0);
            border-radius: 50%;
            position: absolute;
            top: 0;
            left: 7px;
            box-shadow: var(--neon-glow);
            border: 2px solid var(--primary);
        }

        .eye {
            width: 4px;
            height: 4px;
            background: var(--primary);
            border-radius: 50%;
            position: absolute;
            top: 8px;
            animation: blink 4s infinite;
        }

        .eye-left { left: 5px; }
        .eye-right { left: 11px; }

        @keyframes blink {
            0%, 98%, 100% { height: 4px; }
            99% { height: 1px; }
        }

        .torso {
            width: 5px;
            height: 24px;
            background: linear-gradient(180deg, #ffffff, #cccccc);
            position: absolute;
            top: 20px;
            left: 15px;
            border-radius: 3px;
            box-shadow: 0 0 8px rgba(0, 242, 255, 0.6);
        }

        .arm {
            width: 4px;
            height: 16px;
            background: linear-gradient(180deg, #ffffff, #cccccc);
            position: absolute;
            top: 22px;
            border-radius: 2px;
            transform-origin: top;
        }

        .arm-left { left: 10px; transform: rotate(-30deg); }
        .arm-right { left: 21px; transform: rotate(30deg); }

        .leg {
            width: 5px;
            height: 20px;
            background: linear-gradient(180deg, #ffffff, #cccccc);
            position: absolute;
            top: 40px;
            left: 15px;
            transform-origin: top;
            border-radius: 2px;
        }

        .running .leg-l { animation: runLeg 0.3s infinite alternate; }
        .running .leg-r { animation: runLeg 0.3s infinite alternate-reverse; }
        .running .arm-left { animation: runArm 0.3s infinite alternate-reverse; }
        .running .arm-right { animation: runArm 0.3s infinite alternate; }

        @keyframes runLeg {
            from { transform: rotate(-50deg); }
            to { transform: rotate(50deg); }
        }

        @keyframes runArm {
            from { transform: rotate(-60deg); }
            to { transform: rotate(60deg); }
        }

        .sliding {
            transform: scaleY(0.4) !important;
            transform-origin: bottom !important;
        }

        .jumping .leg-l,
        .jumping .leg-r {
            animation: none !important;
            transform: rotate(0deg) !important;
        }

        /* Particles System */
        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 105;
        }

        .dust-particle {
            width: 4px;
            height: 4px;
            background: var(--primary);
            border-radius: 50%;
            opacity: 0.8;
            animation: dustFloat 1s ease-out forwards;
        }

        @keyframes dustFloat {
            0% { 
                transform: translate(0, 0) scale(1); 
                opacity: 0.8; 
            }
            100% { 
                transform: translate(var(--tx), var(--ty)) scale(0); 
                opacity: 0; 
            }
        }

        .death-particle {
            width: 8px;
            height: 8px;
            background: var(--danger);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--danger);
            animation: deathExplode 0.8s ease-out forwards;
        }

        @keyframes deathExplode {
            0% { 
                transform: translate(0, 0) scale(1); 
                opacity: 1; 
            }
            100% { 
                transform: translate(var(--tx), var(--ty)) scale(0); 
                opacity: 0; 
            }
        }

        /* Traps & Obstacles */
        .trap {
            position: absolute;
            z-index: 105;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        /* Spike Trap */
        .spike-trap {
            width: 40px;
            height: 40px;
            bottom: 80px;
        }

        .spike {
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-bottom: 40px solid var(--danger);
            filter: drop-shadow(0 0 15px var(--danger));
            position: relative;
            animation: spikeGlow 2s ease-in-out infinite;
        }

        .spike::before,
        .spike::after {
            content: '';
            position: absolute;
            bottom: -40px;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 20px solid var(--danger);
        }

        .spike::before { left: -30px; }
        .spike::after { left: 10px; }

        @keyframes spikeGlow {
            0%, 100% { filter: drop-shadow(0 0 15px var(--danger)); }
            50% { filter: drop-shadow(0 0 25px var(--danger)) drop-shadow(0 0 35px var(--danger)); }
        }

        /* Laser Beam */
        .laser-beam {
            width: 6px;
            height: 100%;
            background: linear-gradient(180deg, 
                transparent 0%, 
                var(--danger) 10%, 
                var(--danger) 90%, 
                transparent 100%
            );
            box-shadow: 
                0 0 10px var(--danger),
                0 0 20px var(--danger),
                0 0 30px var(--danger);
            animation: laserPulse 1s ease-in-out infinite;
            position: relative;
        }

        .laser-beam::before,
        .laser-beam::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: radial-gradient(circle, var(--danger), transparent);
            border-radius: 50%;
            animation: laserNode 1s ease-in-out infinite;
        }

        .laser-beam::before { top: -10px; }
        .laser-beam::after { bottom: -10px; }

        @keyframes laserPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        @keyframes laserNode {
            0%, 100% { 
                box-shadow: 0 0 10px var(--danger);
                transform: translateX(-50%) scale(1);
            }
            50% { 
                box-shadow: 0 0 20px var(--danger);
                transform: translateX(-50%) scale(1.3);
            }
        }

        /* Saw Blade */
        .saw-blade {
            width: 50px;
            height: 50px;
            bottom: 80px;
        }

        .saw {
            width: 100%;
            height: 100%;
            background: 
                conic-gradient(from 0deg, 
                    var(--danger) 0deg 30deg,
                    transparent 30deg 60deg,
                    var(--danger) 60deg 90deg,
                    transparent 90deg 120deg,
                    var(--danger) 120deg 150deg,
                    transparent 150deg 180deg,
                    var(--danger) 180deg 210deg,
                    transparent 210deg 240deg,
                    var(--danger) 240deg 270deg,
                    transparent 270deg 300deg,
                    var(--danger) 300deg 330deg,
                    transparent 330deg 360deg
                );
            border-radius: 50%;
            animation: sawRotate 1s linear infinite;
            box-shadow: 
                0 0 20px var(--danger),
                inset 0 0 20px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .saw::before {
            content: '';
            position: absolute;
            inset: 15px;
            background: #222;
            border-radius: 50%;
            border: 3px solid var(--danger);
        }

        @keyframes sawRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Moving Platform */
        .moving-platform {
            width: 100px;
            height: 20px;
            background: linear-gradient(180deg, var(--primary), #0088aa);
            border: 2px solid var(--primary);
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.5);
            position: absolute;
            z-index: 104;
        }

        /* Falling Platform */
        .falling-platform {
            width: 100px;
            height: 20px;
            background: linear-gradient(180deg, var(--warning), #cc8800);
            border: 2px solid var(--warning);
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.5);
            position: absolute;
            z-index: 104;
        }

        .falling-platform.falling {
            animation: platformFall 1s ease-in forwards;
        }

        @keyframes platformFall {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(600px) rotate(180deg); opacity: 0; }
        }

        /* Teleporter */
        .teleporter {
            width: 40px;
            height: 80px;
            background: linear-gradient(180deg, 
                transparent,
                rgba(112, 0, 255, 0.3),
                rgba(112, 0, 255, 0.6),
                rgba(112, 0, 255, 0.3),
                transparent
            );
            border-left: 2px solid var(--secondary);
            border-right: 2px solid var(--secondary);
            box-shadow: 
                0 0 20px var(--secondary),
                inset 0 0 20px var(--secondary);
            animation: teleportPulse 2s ease-in-out infinite;
            position: absolute;
            bottom: 80px;
            z-index: 103;
        }

        @keyframes teleportPulse {
            0%, 100% { 
                opacity: 0.6;
                transform: scaleY(1);
            }
            50% { 
                opacity: 1;
                transform: scaleY(1.1);
            }
        }

        /* Electric Field */
        .electric-field {
            width: 80px;
            height: 150px;
            position: absolute;
            bottom: 80px;
            overflow: hidden;
            z-index: 103;
        }

        .lightning {
            position: absolute;
            width: 3px;
            height: 100%;
            background: linear-gradient(180deg, 
                var(--warning),
                var(--primary),
                var(--warning)
            );
            box-shadow: 0 0 10px var(--warning);
            animation: lightningStrike 0.5s ease-in-out infinite;
            left: var(--pos);
        }

        @keyframes lightningStrike {
            0%, 100% { opacity: 0; transform: scaleY(0); }
            50% { opacity: 1; transform: scaleY(1); }
        }

        /* Checkpoint */
        .checkpoint {
            width: 50px;
            height: 80px;
            position: absolute;
            bottom: 80px;
            z-index: 102;
        }

        .checkpoint-pole {
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, #444, #222);
            position: absolute;
            left: 23px;
            border-radius: 2px;
        }

        .checkpoint-flag {
            width: 30px;
            height: 20px;
            background: var(--success);
            position: absolute;
            top: 10px;
            left: 25px;
            clip-path: polygon(0 0, 100% 0, 85% 50%, 100% 100%, 0 100%);
            box-shadow: 0 0 15px var(--success);
            animation: flagWave 2s ease-in-out infinite;
        }

        .checkpoint.inactive .checkpoint-flag {
            background: #444;
            box-shadow: none;
        }

        @keyframes flagWave {
            0%, 100% { transform: rotateY(0deg); }
            50% { transform: rotateY(15deg); }
        }

        /* Finish Flag with Gravity Pull - GLOWING */
        .finish-flag {
            width: 60px;
            height: 120px;
            position: absolute;
            bottom: 80px;
            z-index: 106;
        }

        .finish-pole {
            width: 8px;
            height: 100%;
            background: linear-gradient(180deg, 
                var(--primary),
                var(--warning),
                var(--primary)
            );
            position: absolute;
            left: 26px;
            border-radius: 4px;
            box-shadow: 
                0 0 30px var(--primary),
                0 0 60px var(--primary),
                0 0 90px var(--primary);
            animation: poleGlowIntense 1.5s ease-in-out infinite;
        }

        @keyframes poleGlowIntense {
            0%, 100% { 
                box-shadow: 
                    0 0 30px var(--primary),
                    0 0 60px var(--primary),
                    0 0 90px var(--primary);
                filter: brightness(1);
            }
            50% { 
                box-shadow: 
                    0 0 50px var(--primary),
                    0 0 100px var(--primary),
                    0 0 150px var(--primary),
                    0 0 200px rgba(0, 242, 255, 0.5);
                filter: brightness(1.5);
            }
        }

        .finish-flag-cloth {
            width: 45px;
            height: 35px;
            background: linear-gradient(135deg, 
                var(--primary), 
                var(--secondary),
                var(--primary)
            );
            position: absolute;
            top: 10px;
            left: 32px;
            clip-path: polygon(0 0, 100% 0, 90% 50%, 100% 100%, 0 100%);
            box-shadow: 
                0 0 30px var(--primary),
                0 0 50px var(--primary),
                inset 0 0 20px rgba(255, 255, 255, 0.5);
            animation: finishFlagWaveGlow 1s ease-in-out infinite;
            filter: brightness(1.3);
        }

        @keyframes finishFlagWaveGlow {
            0%, 100% { 
                transform: rotateY(0deg) translateX(0);
                box-shadow: 
                    0 0 30px var(--primary),
                    0 0 50px var(--primary),
                    inset 0 0 20px rgba(255, 255, 255, 0.5);
            }
            50% { 
                transform: rotateY(25deg) translateX(5px);
                box-shadow: 
                    0 0 40px var(--primary),
                    0 0 70px var(--primary),
                    0 0 100px var(--primary),
                    inset 0 0 30px rgba(255, 255, 255, 0.8);
            }
        }

        .finish-flag-icon {
            position: absolute;
            top: 15px;
            left: 45px;
            font-size: 24px;
            animation: iconBounceGlow 1s ease-in-out infinite;
            filter: drop-shadow(0 0 10px var(--primary));
        }

        @keyframes iconBounceGlow {
            0%, 100% { 
                transform: translateY(0) scale(1);
                filter: drop-shadow(0 0 10px var(--primary));
            }
            50% { 
                transform: translateY(-8px) scale(1.1);
                filter: drop-shadow(0 0 20px var(--primary));
            }
        }

        /* BLACK HOLE Gravity Effect */
        .black-hole {
            position: absolute;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: radial-gradient(circle at center,
                transparent 0%,
                transparent 30%,
                rgba(0, 0, 0, 0.9) 35%,
                rgba(0, 0, 0, 1) 40%,
                rgba(112, 0, 255, 0.3) 50%,
                rgba(0, 242, 255, 0.2) 70%,
                transparent 100%
            );
            pointer-events: none;
            z-index: 100;
            animation: blackHoleRotate 4s linear infinite;
        }

        @keyframes blackHoleRotate {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .black-hole::before {
            content: '';
            position: absolute;
            inset: 20%;
            border-radius: 50%;
            background: radial-gradient(circle,
                #000000 0%,
                #000000 40%,
                rgba(112, 0, 255, 0.5) 60%,
                transparent 100%
            );
            animation: blackHolePulse 2s ease-in-out infinite;
        }

        @keyframes blackHolePulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 1;
            }
            50% { 
                transform: scale(0.9);
                opacity: 0.7;
            }
        }

        .black-hole::after {
            content: '';
            position: absolute;
            inset: -20%;
            border-radius: 50%;
            border: 2px solid var(--primary);
            box-shadow: 
                0 0 30px var(--primary),
                inset 0 0 30px var(--primary);
            animation: blackHoleRing 3s linear infinite;
        }

        @keyframes blackHoleRing {
            0% { 
                transform: rotate(0deg) scale(1);
                opacity: 0.6;
            }
            100% { 
                transform: rotate(-360deg) scale(1.2);
                opacity: 0.3;
            }
        }

        /* Gravity Field - Enhanced */
        .gravity-field {
            position: absolute;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: radial-gradient(circle, 
                rgba(0, 242, 255, 0.2) 0%,
                rgba(112, 0, 255, 0.15) 30%,
                rgba(0, 242, 255, 0.1) 50%,
                transparent 100%
            );
            pointer-events: none;
            animation: gravityPulseStrong 2s ease-in-out infinite;
            z-index: 99;
        }

        @keyframes gravityPulseStrong {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
                opacity: 0.5;
            }
            50% { 
                transform: scale(1.3) rotate(180deg);
                opacity: 0.8;
            }
        }

        .gravity-particles {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--warning);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--warning);
            animation: gravityOrbit var(--orbit-duration) linear infinite;
            transform-origin: var(--orbit-x) var(--orbit-y);
        }

        @keyframes gravityOrbit {
            0% { 
                transform: rotate(0deg) translateX(var(--orbit-radius)) rotate(0deg);
                opacity: 1;
            }
            100% { 
                transform: rotate(360deg) translateX(var(--orbit-radius)) rotate(-360deg);
                opacity: 0.3;
            }
        }

        @keyframes rayPulse {
            0%, 100% {
                opacity: 0.3;
                height: 50px;
            }
            50% {
                opacity: 0.8;
                height: 80px;
            }
        }

        /* Player Climbing Flag */
        #player.climbing {
            animation: climbFlag 0.5s ease-in-out forwards;
        }

        @keyframes climbFlag {
            0% { transform: translateX(0) translateY(0); }
            100% { transform: translateX(0) translateY(-20px); }
        }

        /* Chat Bubble */
        .chat-bubble {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--primary);
            border-radius: 15px;
            padding: 8px 15px;
            font-family: 'Rajdhani';
            font-size: 14px;
            font-weight: 700;
            color: var(--primary);
            white-space: nowrap;
            z-index: 120;
            pointer-events: none;
            animation: chatAppear 0.3s ease-out, chatFloat 2s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.5);
        }

        .chat-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 20px;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid var(--primary);
        }

        @keyframes chatAppear {
            0% { 
                transform: translateY(10px) scale(0);
                opacity: 0;
            }
            100% { 
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes chatFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .chat-bubble.flag-grab {
            background: rgba(255, 0, 85, 0.9);
            border-color: var(--danger);
            color: white;
            font-size: 16px;
            animation: chatShake 0.1s ease-in-out infinite, chatAppear 0.3s ease-out;
        }

        @keyframes chatShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        /* Coin Collectible */
        .coin {
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, var(--warning), #cc8800);
            border-radius: 50%;
            border: 3px solid var(--warning);
            box-shadow: 
                0 0 15px var(--warning),
                inset 0 0 10px rgba(255, 255, 255, 0.3);
            position: absolute;
            z-index: 105;
            animation: coinFloat 2s ease-in-out infinite;
        }

        .coin::before {
            content: '$';
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            color: #000;
        }

        @keyframes coinFloat {
            0%, 100% { transform: translateY(0) rotateY(0deg); }
            50% { transform: translateY(-10px) rotateY(180deg); }
        }

        /* Waifu Target */
        #waifu {
            position: absolute;
            bottom: 80px;
            right: 100px;
            width: 50px;
            height: 80px;
            display: none;
            z-index: 106;
            text-align: center;
            animation: waifuFloat 3s ease-in-out infinite;
        }

        @keyframes waifuFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }

        .waifu-label {
            font-size: 10px;
            color: var(--waifu);
            margin-bottom: 5px;
            text-shadow: 0 0 10px var(--waifu);
            font-weight: bold;
            animation: labelPulse 1s ease-in-out infinite;
        }

        @keyframes labelPulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .waifu-sprite {
            width: 30px;
            height: 55px;
            background: linear-gradient(180deg, var(--waifu), #ff6b8a);
            border-radius: 15px 15px 10px 10px;
            margin: 0 auto;
            box-shadow: 
                0 0 25px var(--waifu),
                inset 0 0 15px rgba(255, 255, 255, 0.3);
            position: relative;
        }

        .waifu-sprite::before {
            content: 'â™¥';
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            color: white;
            animation: heartBeat 1s ease-in-out infinite;
        }

        @keyframes heartBeat {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.2); }
        }

        /* HUD System */
        .hud {
            position: absolute;
            top: 25px;
            left: 30px;
            right: 30px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            font-family: 'Orbitron';
            font-size: 14px;
            z-index: 1000;
            pointer-events: none;
            gap: 15px;
        }

        .hud-item {
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border: 1px solid var(--primary);
            border-radius: 4px;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        .hud-label {
            color: var(--primary);
            font-weight: 600;
            font-size: 11px;
            margin-bottom: 3px;
        }

        .hud-value {
            color: white;
            font-weight: 700;
            font-size: 18px;
            text-shadow: 0 0 10px var(--primary);
        }

        /* Progress Bar */
        .progress-bar {
            position: absolute;
            top: 80px;
            left: 30px;
            right: 30px;
            height: 8px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--primary);
            border-radius: 4px;
            overflow: hidden;
            z-index: 1000;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--secondary), var(--primary));
            box-shadow: 0 0 15px var(--primary);
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Mini Map */
        .minimap {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 200px;
            height: 60px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--primary);
            border-radius: 4px;
            z-index: 1000;
            padding: 5px;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.3);
        }

        .minimap-player {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--primary);
            border-radius: 50%;
            box-shadow: 0 0 5px var(--primary);
            top: 50%;
            transform: translateY(-50%);
        }

        .minimap-trap {
            position: absolute;
            width: 3px;
            height: 3px;
            background: var(--danger);
            border-radius: 50%;
            top: 50%;
            transform: translateY(-50%);
        }

        .minimap-end {
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--success);
            border-radius: 50%;
            box-shadow: 0 0 8px var(--success);
            top: 50%;
            right: 5px;
            transform: translateY(-50%);
        }

        /* Overlay System */
        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(20px);
            animation: overlayFadeIn 0.3s ease-out;
        }

        @keyframes overlayFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .card {
            padding: 50px 60px;
            border: 2px solid var(--primary);
            background: linear-gradient(135deg, #0a0a12 0%, #15152a 100%);
            text-align: center;
            border-radius: 8px;
            box-shadow: 
                0 0 50px rgba(0, 242, 255, 0.3),
                inset 0 0 30px rgba(0, 0, 0, 0.5);
            animation: cardSlideIn 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            max-width: 600px;
        }

        @keyframes cardSlideIn {
            from { 
                transform: translateY(-50px) scale(0.9);
                opacity: 0;
            }
            to { 
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .card h1 {
            margin: 0 0 20px 0;
            font-family: 'Orbitron';
            font-size: 42px;
            font-weight: 900;
            text-shadow: 0 0 20px currentColor;
            animation: titleGlow 2s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% { text-shadow: 0 0 20px currentColor; }
            50% { text-shadow: 0 0 30px currentColor, 0 0 40px currentColor; }
        }

        .card p {
            color: #aaa;
            margin: 20px 0;
            font-size: 16px;
            line-height: 1.6;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border: 1px solid var(--primary);
            border-radius: 4px;
        }

        .stat-label {
            font-size: 11px;
            color: var(--primary);
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: white;
        }

        button {
            background: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: 15px 50px;
            cursor: pointer;
            font-family: 'Orbitron';
            font-size: 18px;
            font-weight: 700;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            margin: 10px;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--primary);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.3s ease;
            z-index: -1;
        }

        button:hover::before {
            transform: scaleX(1);
        }

        button:hover {
            color: #000;
            box-shadow: 0 0 30px var(--primary);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        /* Tutorial Tooltip */
        .tutorial {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--primary);
            padding: 30px;
            border-radius: 8px;
            max-width: 500px;
            z-index: 1500;
            animation: tooltipBounce 1s ease-in-out infinite;
            display: none;
        }

        @keyframes tooltipBounce {
            0%, 100% { transform: translate(-50%, -50%); }
            50% { transform: translate(-50%, -55%); }
        }

        .tutorial h3 {
            color: var(--primary);
            margin: 0 0 15px 0;
            font-family: 'Orbitron';
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .control-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .key {
            background: var(--primary);
            color: #000;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            font-family: 'Orbitron';
            min-width: 40px;
            text-align: center;
            box-shadow: 0 0 10px var(--primary);
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            position: absolute;
            bottom: 120px;
            left: 0;
            right: 0;
            z-index: 1500;
            justify-content: space-around;
            padding: 0 30px;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(0, 242, 255, 0.2);
            border: 2px solid var(--primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: var(--primary);
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
        }

        .control-btn:active {
            background: rgba(0, 242, 255, 0.5);
            transform: scale(0.95);
        }

        /* Show mobile controls on landscape mobile/tablet */
        @media (max-width: 926px) and (orientation: landscape) {
            .mobile-controls { 
                display: flex !important; 
                bottom: 15px !important;
            }
            
            .control-btn {
                width: 55px !important;
                height: 55px !important;
                font-size: 22px !important;
            }
        }

        @media (min-width: 927px) and (max-width: 1250px) {
            .mobile-controls { display: flex; }
        }

        /* Warning Signs */
        .warning-sign {
            position: absolute;
            width: 40px;
            height: 40px;
            bottom: 140px;
            z-index: 108;
            animation: warningBlink 0.5s ease-in-out infinite;
        }

        .warning-triangle {
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-bottom: 35px solid var(--warning);
            position: relative;
            filter: drop-shadow(0 0 10px var(--warning));
        }

        .warning-triangle::before {
            content: '!';
            position: absolute;
            bottom: -28px;
            left: 50%;
            transform: translateX(-50%);
            color: #000;
            font-weight: bold;
            font-size: 20px;
        }

        @keyframes warningBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        /* Achievement Popup */
        .achievement {
            position: absolute;
            top: 120px;
            right: -400px;
            width: 350px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--success);
            border-radius: 8px;
            padding: 20px;
            z-index: 3000;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            transition: right 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .achievement.show {
            right: 30px;
        }

        .achievement-title {
            color: var(--success);
            font-family: 'Orbitron';
            font-size: 16px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px var(--success);
        }

        .achievement-desc {
            color: #aaa;
            font-size: 14px;
        }

        /* ==================== MOBILE LANDSCAPE & LOADING ==================== */
        .rotate-message {
            display: none;
            position: fixed;
            inset: 0;
            background: var(--bg);
            z-index: 99999;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 30px;
        }

        .rotate-icon {
            font-size: clamp(60px, 15vw, 100px);
            animation: rotatePhone 2s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes rotatePhone {
            0%, 100% { transform: rotate(0deg); }
            25%, 75% { transform: rotate(-90deg); }
        }

        .rotate-text {
            font-family: 'Orbitron';
            font-size: clamp(20px, 5vw, 28px);
            color: var(--primary);
            text-shadow: var(--neon-glow);
            margin-bottom: 15px;
            font-weight: 900;
        }

        .rotate-subtext {
            font-size: clamp(14px, 3vw, 18px);
            color: #888;
            line-height: 1.6;
        }

        /* Show rotate message ONLY in portrait mode on mobile */
        @media screen and (orientation: portrait) and (max-width: 768px) {
            .rotate-message {
                display: flex !important;
            }
            #game-container {
                display: none !important;
            }
            #loading-screen {
                display: none !important;
            }
            #main-menu {
                display: none !important;
            }
            #level-select {
                display: none !important;
            }
        }

        /* Hide rotate message in landscape */
        @media screen and (orientation: landscape) {
            .rotate-message {
                display: none !important;
            }
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #020205 0%, #0a0a1e 50%, #020205 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s, visibility 0.5s;
        }

        #loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .loading-logo {
            font-family: 'Orbitron';
            font-size: clamp(32px, 6vw, 56px);
            font-weight: 900;
            color: var(--primary);
            text-shadow: var(--neon-glow);
            margin-bottom: 40px;
            animation: logoGlow 2s ease-in-out infinite;
            text-align: center;
            padding: 0 20px;
        }

        .loading-subtitle {
            font-size: clamp(14px, 3vw, 20px);
            color: var(--danger);
            margin-bottom: 60px;
            animation: blink 1s infinite;
            text-align: center;
            padding: 0 20px;
        }

        .loading-bar-container {
            width: 80%;
            max-width: 500px;
            height: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--primary);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.3);
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--secondary), var(--primary));
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
            box-shadow: 0 0 20px var(--primary);
        }

        .loading-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shine 2s infinite;
        }

        .loading-text {
            margin-top: 20px;
            font-size: clamp(12px, 2vw, 16px);
            color: var(--primary);
            font-family: 'Orbitron';
            text-align: center;
        }

        .loading-tips {
            margin-top: 40px;
            max-width: 600px;
            text-align: center;
            padding: 20px;
            color: #888;
            font-size: clamp(12px, 2vw, 15px);
            line-height: 1.6;
        }

        .tip-label {
            color: var(--warning);
            font-weight: 700;
            margin-bottom: 10px;
        }

        /* Main Menu */
        #main-menu {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #020205 0%, #1a1a2e 50%, #020205 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9000;
            padding: 20px;
        }

        #main-menu.active {
            display: flex;
        }

        .menu-logo {
            font-family: 'Orbitron';
            font-size: clamp(36px, 7vw, 64px);
            font-weight: 900;
            color: var(--primary);
            text-shadow: var(--neon-glow);
            margin-bottom: 20px;
            animation: logoGlow 2s ease-in-out infinite;
            text-align: center;
        }

        .menu-subtitle {
            font-size: clamp(16px, 3vw, 22px);
            color: var(--danger);
            margin-bottom: 50px;
            text-align: center;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            max-width: 400px;
        }

        .menu-btn {
            background: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: clamp(15px, 2.5vw, 20px) clamp(40px, 6vw, 60px);
            cursor: pointer;
            font-family: 'Orbitron';
            font-size: clamp(16px, 3vw, 20px);
            font-weight: 700;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            text-align: center;
        }

        .menu-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--primary);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.3s ease;
            z-index: -1;
        }

        .menu-btn:hover::before,
        .menu-btn:active::before {
            transform: scaleX(1);
        }

        .menu-btn:hover,
        .menu-btn:active {
            color: #000;
            box-shadow: 0 0 30px var(--primary);
            transform: translateY(-2px);
        }

        .menu-stats {
            margin-top: 40px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 500px;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--primary);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        /* Level Select */
        #level-select {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #020205 0%, #0a0a1e 50%, #020205 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            z-index: 9000;
            overflow-y: auto;
        }

        #level-select.active {
            display: flex;
        }

        .level-select-header {
            width: 100%;
            max-width: 900px;
            margin-bottom: 30px;
            text-align: center;
        }

        .level-select-title {
            font-family: 'Orbitron';
            font-size: clamp(28px, 6vw, 48px);
            color: var(--primary);
            text-shadow: var(--neon-glow);
            margin-bottom: 15px;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 900px;
            margin-bottom: 30px;
        }

        .level-card {
            background: linear-gradient(135deg, #0a0a12 0%, #15152a 100%);
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .level-card::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--primary);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 0;
        }

        .level-card:hover::before,
        .level-card:active::before {
            opacity: 0.1;
        }

        .level-card:hover,
        .level-card:active {
            transform: translateY(-5px);
            box-shadow: 0 10px 40px rgba(0, 242, 255, 0.5);
        }

        .level-card.locked {
            opacity: 0.4;
            cursor: not-allowed;
            border-color: #444;
        }

        .level-card.locked:hover {
            transform: none;
            box-shadow: none;
        }

        .level-number {
            font-family: 'Orbitron';
            font-size: clamp(32px, 6vw, 42px);
            font-weight: 900;
            color: var(--primary);
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
        }

        .level-name {
            font-size: clamp(13px, 2.5vw, 16px);
            color: #aaa;
            margin-bottom: 15px;
            position: relative;
            z-index: 1;
        }

        .level-stats {
            display: flex;
            justify-content: space-around;
            font-size: clamp(11px, 2vw, 13px);
            color: #666;
            position: relative;
            z-index: 1;
        }

        .level-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .level-stat-icon {
            font-size: clamp(18px, 3vw, 22px);
        }

        .back-btn {
            background: transparent;
            border: 2px solid var(--danger);
            color: var(--danger);
            padding: 12px 40px;
            cursor: pointer;
            font-family: 'Orbitron';
            font-size: clamp(16px, 2.5vw, 20px);
            font-weight: 700;
            transition: all 0.3s;
            border-radius: 8px;
            margin-top: 20px;
        }

        .back-btn:hover,
        .back-btn:active {
            background: var(--danger);
            color: #000;
            box-shadow: 0 0 30px var(--danger);
        }

        /* Pause Menu */
        .pause-btn {
            position: absolute;
            top: 25px;
            right: 30px;
            width: 45px;
            height: 45px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1001;
            font-size: 20px;
            color: var(--primary);
            transition: all 0.3s;
            pointer-events: all;
        }

        .pause-btn:hover,
        .pause-btn:active {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 20px var(--primary);
        }

        #pause-overlay .card {
            max-width: 500px;
        }

        .pause-menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .pause-menu-buttons button {
            width: 100%;
            margin: 0;
        }

        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #stage.hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Rotate Screen Message -->
    <div class="rotate-message">
        <div class="rotate-icon">ðŸ“±â†»</div>
        <div class="rotate-text">XOAY NGANG MÃ€N HÃŒNH</div>
        <div class="rotate-subtext">
            Äá»ƒ chÆ¡i game, vui lÃ²ng xoay Ä‘iá»‡n thoáº¡i ngang<br>
            ðŸŽ® Tráº£i nghiá»‡m tá»‘t nháº¥t á»Ÿ cháº¿ Ä‘á»™ landscape ðŸŽ®
        </div>
    </div>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-logo">UNFAIR ODYSSEY</div>
        <div class="loading-subtitle">ðŸ’€ LÆ¯Æ NG 8 TRIá»†U EDITION ðŸ’€</div>
        
        <div class="loading-bar-container">
            <div class="loading-bar" id="loading-bar"></div>
        </div>
        
        <div class="loading-text" id="loading-text">Äang khá»Ÿi Ä‘á»™ng há»‡ thá»‘ng...</div>
        
        <div class="loading-tips">
            <div class="tip-label">ðŸ’¡ Máº¸O SINH Tá»’N DÃ€NH CHO DÃ‚N VÄ‚N PHÃ’NG:</div>
            <div id="loading-tip">
                "LÆ°Æ¡ng 8 triá»‡u, Ä‘á»c tin nháº¯n má»™t ná»­a - Ä‘Ã³ lÃ  nghá»‡ thuáº­t sá»‘ng cÃ²n!"
            </div>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="main-menu">
        <div class="menu-logo">UNFAIR ODYSSEY</div>
        <div class="menu-subtitle">ðŸ’€ LÆ°Æ¡ng 8tr Edition - Äá»c Tin Nháº¯n 50% ðŸ’€</div>
        
        <div class="menu-buttons">
            <button class="menu-btn" onclick="gameManager.startGame()">
                â–¶ï¸ Báº®T Äáº¦U NHIá»†M Vá»¤
            </button>
            <button class="menu-btn" onclick="gameManager.showLevelSelect()">
                ðŸŽ¯ CHá»ŒN MÃ€N CHÆ I
            </button>
            <button class="menu-btn" onclick="gameManager.resetProgress()">
                ðŸ”„ RESET TIáº¾N TRÃŒNH
            </button>
        </div>

        <div class="menu-stats">
            <div class="stat-card">
                <div class="stat-label">Tá»”NG CHáº¾T</div>
                <div class="stat-value" id="menu-deaths">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">COINS</div>
                <div class="stat-value" id="menu-coins">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">MÃ€N CAO NHáº¤T</div>
                <div class="stat-value" id="menu-level">1</div>
            </div>
        </div>
    </div>

    <!-- Level Select -->
    <div id="level-select">
        <div class="level-select-header">
            <div class="level-select-title">CHá»ŒN SECTOR</div>
        </div>

        <div class="level-grid" id="level-grid">
            <!-- Generated by JS -->
        </div>

        <button class="back-btn" onclick="gameManager.showMainMenu()">
            â† TRá»ž Láº I
        </button>
    </div>

    <div id="game-container">
    <div id="stage" class="hidden">
        <!-- Background Layers -->
        <div class="layer sky"></div>
        <div class="layer nebula"></div>
        <div class="layer stars"></div>
        <div id="mountains-far" class="layer mountains-far"></div>
        <div id="mountains-near" class="layer mountains-near"></div>

        <!-- HUD -->
        <div class="hud">
            <div class="hud-item">
                <div class="hud-label">STATUS</div>
                <div class="hud-value" id="status">ACTIVE</div>
            </div>
            <div class="hud-item">
                <div class="hud-label">SECTOR</div>
                <div class="hud-value"><span id="lvl">1</span>/10</div>
            </div>
            <div class="hud-item">
                <div class="hud-label">DEATHS</div>
                <div class="hud-value" id="deaths">0</div>
            </div>
            <div class="hud-item">
                <div class="hud-label">COINS</div>
                <div class="hud-value" id="coins">0</div>
            </div>
            <div class="hud-item">
                <div class="hud-label">TIME</div>
                <div class="hud-value" id="timer">0:00</div>
            </div>
        </div>

        <!-- Progress Bar -->
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>

        <!-- Mini Map -->
        <div class="minimap">
            <div class="minimap-player" id="minimap-player"></div>
            <div class="minimap-end"></div>
            <div id="minimap-traps"></div>
        </div>

        <!-- Floor -->
        <div id="floor"></div>

        <!-- Player -->
        <div id="player">
            <div class="head">
                <div class="eye eye-left"></div>
                <div class="eye eye-right"></div>
            </div>
            <div class="torso"></div>
            <div class="arm arm-left"></div>
            <div class="arm arm-right"></div>
            <div class="leg leg-l"></div>
            <div class="leg leg-r"></div>
        </div>

        <!-- Waifu Target -->
        <div id="waifu">
            <div class="waifu-label">TARGET_LOCKED</div>
            <div class="waifu-sprite"></div>
        </div>

        <!-- Dynamic Content Layer -->
        <div id="traps-layer"></div>
        <div id="particles-layer"></div>
        <div id="warnings-layer"></div>

        <!-- Tutorial -->
        <div id="tutorial" class="tutorial">
            <h3>âš¡ CONTROLS</h3>
            <div class="controls">
                <div class="control-item">
                    <div class="key">â†’</div>
                    <span>Move Right</span>
                </div>
                <div class="control-item">
                    <div class="key">â†</div>
                    <span>Move Left</span>
                </div>
                <div class="control-item">
                    <div class="key">â†‘</div>
                    <span>Jump</span>
                </div>
                <div class="control-item">
                    <div class="key">â†“</div>
                    <span>Slide</span>
                </div>
            </div>
            <button onclick="engine.closeTutorial()">START MISSION</button>
        </div>

        <!-- Pause Button -->
        <div class="pause-btn" onclick="engine.togglePause()">â¸ï¸</div>

        <!-- Mobile Controls -->
        <div class="mobile-controls">
            <div class="control-btn" data-key="ArrowLeft">â†</div>
            <div class="control-btn" data-key="ArrowUp">â†‘</div>
            <div class="control-btn" data-key="ArrowDown">â†“</div>
            <div class="control-btn" data-key="ArrowRight">â†’</div>
        </div>

        <!-- Overlays -->
        <div id="msg-overlay" class="overlay">
            <div class="card">
                <h1 id="msg-title">SIGNAL LOST</h1>
                <p id="msg-desc"></p>
                <div id="stats-container"></div>
                <div>
                    <button onclick="engine.restart()">RETRY</button>
                    <button onclick="engine.nextLevel()" id="next-btn">NEXT SECTOR</button>
                    <button onclick="gameManager.showMainMenu()">ðŸ  MENU</button>
                </div>
            </div>
        </div>

        <!-- Pause Overlay -->
        <div id="pause-overlay" class="overlay">
            <div class="card">
                <h1 style="color: var(--warning);">â¸ï¸ Táº M Dá»ªNG</h1>
                <p>Nghá»‰ tay chÃºt Ä‘i boss! LÆ°Æ¡ng 8tr mÃ  lÃ m cÄƒng tháº¿ ðŸ˜Ž</p>
                <div class="pause-menu-buttons">
                    <button onclick="engine.togglePause()">â–¶ï¸ TIáº¾P Tá»¤C</button>
                    <button onclick="engine.restartLevel()">â†» CHÆ I Láº I MÃ€N</button>
                    <button onclick="gameManager.showMainMenu()">ðŸ  Vá»€ MENU</button>
                </div>
            </div>
        </div>

        <!-- Achievement Notification -->
        <div id="achievement" class="achievement">
            <div class="achievement-title">ðŸ† ACHIEVEMENT UNLOCKED</div>
            <div class="achievement-desc" id="achievement-desc"></div>
        </div>
    </div>
    </div><!-- Close game-container -->

<script>
/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *  UNFAIR ODYSSEY: LÆ¯Æ NG 8 TRIá»†U EDITION
 *  Professional Game Engine - "Äá»c Tin Nháº¯n 50%"
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

// Loading Tips vá» "LÆ°Æ¡ng 8tr - Äá»c tin 50%"
const LOADING_TIPS = [
    '"LÆ°Æ¡ng 8 triá»‡u, Ä‘á»c tin nháº¯n má»™t ná»­a" - BÃ­ quyáº¿t dÃ¢n vÄƒn phÃ²ng! ðŸ˜Ž',
    'Boss há»i: "Xong viá»‡c chÆ°a?" - Báº¡n: "Äang loading Ä‘Ã¢y sáº¿p Æ¡i!" ðŸ’¼',
    'Tip: Nháº£y cao = TrÃ¡nh báº«y. Nháº£y tháº¥p = RIP. ÄÆ¡n giáº£n váº­y thÃ´i! ðŸ¦˜',
    'Game nÃ y khÃ³ hÆ¡n cáº£ viá»‡c xin tÄƒng lÆ°Æ¡ng! ðŸ’°',
    'Cháº¿t 100 láº§n = Báº¡n sáº½... váº«n cháº¿t á»Ÿ láº§n 101! ðŸ’€',
    'Há»p 1 tiáº¿ng = ThÃ´ng tin 15 phÃºt. ChÆ¡i game nÃ y cÅ©ng váº­y! â°',
    'Deadline vÃ  báº«y game: Äá»u Ä‘áº¿n báº¥t ngá» vÃ  cháº¿t ngÆ°á»i! ðŸ“…',
    'LÆ°Æ¡ng 8tr nhÆ°ng skills trÃ¡nh báº«y 80tr! ÄÃ¡ng giÃ¡! ðŸŽ¯',
    'Email dÃ i 3 trang = Äá»c 2 dÃ²ng Ä‘áº§u. Báº«y nhiá»u váº­y = TrÃ¡nh kiá»ƒu gÃ¬? ðŸ“§',
    'Sáº¿p: "LÃ m nhanh lÃªn!" - Game: "Cháº¡y nhanh lÃªn!" - Káº¿t quáº£: ðŸ’€',
    'LÆ°Æ¡ng thÃ¡ng 8tr, tiá»n bonus = 0Ä‘. CÅ©ng giá»‘ng game nÃ y: nhiá»u coin nhÆ°ng vÃ´ dá»¥ng! ðŸ¤‘',
    'OT khÃ´ng lÆ°Æ¡ng = ChÆ¡i game khÃ´ng Ä‘Æ°á»£c gÃ¬. NhÆ°ng váº«n cá»© chÆ¡i! ðŸ˜…'
];

// Chat messages when dodging traps
const DODGE_MESSAGES = [
    'ðŸ˜Ž EZ!',
    'ðŸ’ª Pro player Ä‘Ã¢y!',
    'ðŸ”¥ QuÃ¡ dá»…!',
    'âš¡ Nhanh vÃ£i!',
    'ðŸ˜ Skill issue? Not me!',
    'ðŸŽ¯ Calculated!',
    'ðŸ’€ Gáº§n cháº¿t!',
    'ðŸ˜± á»i giá»i!',
    'ðŸƒ Phew!',
    'ðŸ’¨ Too fast!',
    'ðŸ¤™ Chill!',
    'ðŸŽ® GG EZ!',
    'âš”ï¸ Dodge master!',
    'ðŸŒŸ Smooth!',
    'ðŸ˜¤ Tao lÃ  pro!',
    'ðŸ”¥ On fire!',
    'âš¡ Lightning reflexes!',
    'ðŸ’Ž Diamond hands!',
    'ðŸŽª Circus!',
    'ðŸ˜… Lucky!',
    'ðŸ€ May quÃ¡!',
    'ðŸ’ª Tao máº¡nh máº½!',
    'ðŸ˜Ž Sáº¿p gá»i lÃ  tao nÃ©!',
    'ðŸ“§ NÃ© email, nÃ© báº«y!',
    'â° Deadline? Tao nÃ©!',
    'ðŸ’¼ Skill vÄƒn phÃ²ng!',
    'ðŸŽ¯ LÆ°Æ¡ng 8tr, skill 80tr!'
];

// Flag grab messages
const FLAG_GRAB_MESSAGES = [
    'ðŸ˜± BUÃ”NG TAO RA!',
    'ðŸ’€ NOOOO!',
    'âš¡ TÃ€O Bá»Š HÃšT!',
    'ðŸ˜­ HELP ME!',
    'ðŸ”¥ THÃ”I XÃ€!',
    'ðŸ’¥ Äá»ªA TAO ÄI!',
    'ðŸ˜¡ BUÃ”NG RA!',
    'âš°ï¸ TAO CHÆ¯A MUá»N WIN!',
    'ðŸŽ¯ Äá»‚ TAO CHÆ I THÃŠM!'
];

// Level Names
const LEVEL_NAMES = [
    'Intern Hell',
    'Thá»­ Viá»‡c Äá»‹a Ngá»¥c', 
    'Meeting Marathon',
    'Deadline Crisis',
    'Boss Fight Zone',
    'OT Nightmare',
    'Email Storm',
    'Coffee Break Trap',
    'Salary Day Chaos',
    'CEO Final Boss'
];

class LoadingManager {
    constructor() {
        this.progress = 0;
        this.loadingScreen = document.getElementById('loading-screen');
        this.loadingBar = document.getElementById('loading-bar');
        this.loadingText = document.getElementById('loading-text');
        this.loadingTip = document.getElementById('loading-tip');
    }

    start() {
        this.showRandomTip();
        this.simulateLoading();
    }

    showRandomTip() {
        const tip = LOADING_TIPS[Math.floor(Math.random() * LOADING_TIPS.length)];
        this.loadingTip.textContent = tip;
    }

    simulateLoading() {
        const steps = [
            { progress: 15, text: 'Äang táº£i báº«y gai nhá»n... ðŸ—¡ï¸', delay: 300 },
            { progress: 30, text: 'Äang setup laser cháº¿t ngÆ°á»i... âš¡', delay: 400 },
            { progress: 45, text: 'Äang chuáº©n bá»‹ lÆ°á»¡i cÆ°a... âš™ï¸', delay: 350 },
            { progress: 60, text: 'Äang test Ä‘á»™ khÃ³... ðŸ˜ˆ', delay: 300 },
            { progress: 75, text: 'Äang tÃ­nh lÆ°Æ¡ng 8tr/thÃ¡ng... ðŸ’°', delay: 400 },
            { progress: 90, text: 'Äang Ä‘á»c 50% tin nháº¯n... ðŸ“±', delay: 300 },
            { progress: 100, text: 'Sáºµn sÃ ng chiáº¿n! ðŸš€', delay: 200 }
        ];

        let currentStep = 0;

        const loadStep = () => {
            if (currentStep < steps.length) {
                const step = steps[currentStep];
                this.setProgress(step.progress, step.text);
                currentStep++;
                setTimeout(loadStep, step.delay);
            } else {
                setTimeout(() => this.complete(), 500);
            }
        };

        loadStep();
    }

    setProgress(percent, text) {
        this.progress = percent;
        this.loadingBar.style.width = percent + '%';
        this.loadingText.textContent = text;
    }

    complete() {
        this.loadingScreen.classList.add('hidden');
        gameManager.showMainMenu();
    }
}

class GameManager {
    constructor() {
        this.maxLevel = parseInt(localStorage.getItem('unfair_max_level')) || 1;
        this.currentLevel = 1;
    }

    showMainMenu() {
        document.getElementById('stage').classList.add('hidden');
        document.getElementById('level-select').classList.remove('active');
        document.getElementById('main-menu').classList.add('active');
        
        // Update stats
        const deaths = parseInt(localStorage.getItem('unfair_deaths')) || 0;
        const coins = parseInt(localStorage.getItem('unfair_coins')) || 0;
        
        document.getElementById('menu-deaths').textContent = deaths;
        document.getElementById('menu-coins').textContent = coins;
        document.getElementById('menu-level').textContent = this.maxLevel;
        
        // Stop game if running
        if (window.engine) {
            engine.isPaused = true;
        }
    }

    showLevelSelect() {
        document.getElementById('main-menu').classList.remove('active');
        document.getElementById('level-select').classList.add('active');
        
        this.renderLevelGrid();
    }

    renderLevelGrid() {
        const grid = document.getElementById('level-grid');
        grid.innerHTML = '';
        
        for (let i = 1; i <= CONFIG.GAME.totalLevels; i++) {
            const card = document.createElement('div');
            card.className = 'level-card';
            
            if (i > this.maxLevel) {
                card.classList.add('locked');
            } else {
                card.onclick = () => this.startLevel(i);
            }
            
            const levelStats = JSON.parse(localStorage.getItem(`unfair_level_${i}_stats`)) || {
                deaths: 0,
                coins: 0,
                completed: false
            };
            
            card.innerHTML = `
                <div class="level-number">${i > this.maxLevel ? 'ðŸ”’' : i}</div>
                <div class="level-name">${LEVEL_NAMES[i-1]}</div>
                <div class="level-stats">
                    <div class="level-stat">
                        <div class="level-stat-icon">ðŸ’€</div>
                        <div>${levelStats.deaths}</div>
                    </div>
                    <div class="level-stat">
                        <div class="level-stat-icon">ðŸ’°</div>
                        <div>${levelStats.coins}</div>
                    </div>
                    <div class="level-stat">
                        <div class="level-stat-icon">${levelStats.completed ? 'âœ…' : 'â³'}</div>
                    </div>
                </div>
            `;
            
            grid.appendChild(card);
        }
    }

    startGame() {
        this.startLevel(1);
    }

    startLevel(levelNum) {
        this.currentLevel = levelNum;
        document.getElementById('main-menu').classList.remove('active');
        document.getElementById('level-select').classList.remove('active');
        document.getElementById('stage').classList.remove('hidden');
        
        // Initialize or restart engine
        if (!window.engine) {
            window.engine = new GameEngine(levelNum);
        } else {
            engine.level = levelNum;
            engine.setupLevel(levelNum);
            engine.isPaused = false;
        }
    }

    resetProgress() {
        if (confirm('Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a toÃ n bá»™ tiáº¿n trÃ¬nh?\n(Sáº½ máº¥t táº¥t cáº£: deaths, coins, levels Ä‘Ã£ má»Ÿ)')) {
            localStorage.clear();
            this.maxLevel = 1;
            alert('ÄÃ£ reset! ChÃºc may máº¯n láº§n nÃ y! ðŸ’€');
            location.reload();
        }
    }
}

const CONFIG = {
    // Physics Constants
    PHYSICS: {
        gravity: 0.8,
        jumpForce: -16,
        moveSpeed: 7,
        slideSpeed: 9,
        groundY: 80,
        friction: 0.85
    },
    
    // Game Settings
    GAME: {
        totalLevels: 10,
        levelWidth: 2500,
        invincibilityTime: 2000,
        checkpointDistance: 800
    },
    
    // Visual Settings
    VISUAL: {
        particlesPerStep: 2,
        deathParticles: 20,
        parallaxFarSpeed: 0.15,
        parallaxNearSpeed: 0.4
    }
};

class ParticleSystem {
    constructor() {
        this.particles = [];
        this.layer = document.getElementById('particles-layer');
    }

    createDustParticles(x, y) {
        for (let i = 0; i < CONFIG.VISUAL.particlesPerStep; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle dust-particle';
            
            const tx = (Math.random() - 0.5) * 40;
            const ty = Math.random() * -30;
            
            particle.style.left = x + 'px';
            particle.style.bottom = y + 'px';
            particle.style.setProperty('--tx', tx + 'px');
            particle.style.setProperty('--ty', ty + 'px');
            
            this.layer.appendChild(particle);
            
            setTimeout(() => particle.remove(), 1000);
        }
    }

    createDeathExplosion(x, y) {
        for (let i = 0; i < CONFIG.VISUAL.deathParticles; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle death-particle';
            
            const angle = (Math.PI * 2 * i) / CONFIG.VISUAL.deathParticles;
            const speed = 50 + Math.random() * 50;
            const tx = Math.cos(angle) * speed;
            const ty = Math.sin(angle) * speed;
            
            particle.style.left = x + 'px';
            particle.style.bottom = y + 'px';
            particle.style.setProperty('--tx', tx + 'px');
            particle.style.setProperty('--ty', ty + 'px');
            
            this.layer.appendChild(particle);
            
            setTimeout(() => particle.remove(), 800);
        }
    }

    clear() {
        this.layer.innerHTML = '';
    }
}

class TrapGenerator {
    constructor() {
        this.trapTypes = [
            'spike-trap',
            'laser-beam',
            'saw-blade',
            'electric-field'
        ];
    }

    generateLevel(levelNum) {
        const traps = [];
        const complexity = Math.min(levelNum, 8);
        const trapCount = 8 + (complexity * 2);
        const levelWidth = CONFIG.GAME.levelWidth;

        // Generate varied traps with RANDOM appearances
        for (let i = 0; i < trapCount; i++) {
            const x = 250 + (i * (levelWidth / trapCount)) + (Math.random() * 150 - 75);
            const trapType = this.trapTypes[Math.floor(Math.random() * this.trapTypes.length)];
            
            let trap = {
                x: x,
                type: trapType,
                active: true,
                // Random appearance settings
                appearDelay: Math.random() * 2000, // 0-2 seconds delay
                appearRandom: Math.random() < 0.4, // 40% chance of random pop
                appearDistance: 80 + Math.random() * 120 // Distance trigger
            };

            // Type-specific properties
            if (trapType === 'spike-trap') {
                trap.hidden = (Math.random() < 0.6 && levelNum > 1); // 60% chance hidden
                trap.popup = trap.hidden;
                trap.fakeout = Math.random() < 0.2; // 20% chance it's a fake
            } else if (trapType === 'laser-beam') {
                trap.position = i % 2 === 0 ? 'top' : 'bottom';
                trap.height = 200 + Math.random() * 150;
                trap.blinking = Math.random() < 0.3; // 30% blink on/off
                trap.blinkInterval = 800 + Math.random() * 700;
            } else if (trapType === 'saw-blade') {
                trap.moving = levelNum > 4 || Math.random() < 0.4;
                trap.moveRange = 100 + Math.random() * 150;
                trap.moveSpeed = 1.5 + Math.random() * 2;
                trap.randomReverse = Math.random() < 0.3; // Random direction change
            } else if (trapType === 'electric-field') {
                trap.width = 60 + Math.random() * 40;
                trap.strikeInterval = 400 + Math.random() * 800;
                trap.randomStrike = true; // Always random
            }

            traps.push(trap);
        }

        // Add SURPRISE traps that appear randomly during gameplay
        const surpriseCount = 3 + Math.floor(levelNum / 2);
        for (let i = 0; i < surpriseCount; i++) {
            traps.push({
                type: 'spike-trap',
                x: 300 + (Math.random() * (levelWidth - 600)),
                hidden: true,
                popup: true,
                active: true,
                surprise: true,
                surpriseTime: 3000 + Math.random() * 10000, // Appear 3-13 seconds into level
                appearDelay: 0,
                appearRandom: true
            });
        }

        // Add fake safe zones (traps that look safe but aren't!)
        if (levelNum > 3) {
            const fakeCount = 2 + Math.floor(levelNum / 3);
            for (let i = 0; i < fakeCount; i++) {
                traps.push({
                    type: 'laser-beam',
                    x: 400 + (Math.random() * (levelWidth - 800)),
                    position: 'bottom',
                    height: 100,
                    active: false, // Starts inactive!
                    surprise: true,
                    surpriseTime: 5000 + Math.random() * 8000,
                    appearDelay: 0,
                    appearRandom: true
                });
            }
        }

        // Add special elements
        if (levelNum > 2) {
            // Teleporters
            traps.push({
                type: 'teleporter',
                x: 400 + Math.random() * 300,
                targetX: 1200 + Math.random() * 500,
                active: true
            });
        }

        if (levelNum > 3) {
            // Moving platforms
            for (let i = 0; i < 2; i++) {
                traps.push({
                    type: 'moving-platform',
                    x: 500 + (i * 600),
                    y: 150 + (i * 50),
                    moveRange: 200,
                    moveSpeed: 1.5,
                    active: true
                });
            }
        }

        if (levelNum > 5) {
            // Falling platforms
            traps.push({
                type: 'falling-platform',
                x: 800 + Math.random() * 400,
                y: 200,
                active: true
            });
        }

        // Add coins
        const coinCount = 5 + levelNum;
        for (let i = 0; i < coinCount; i++) {
            traps.push({
                type: 'coin',
                x: 200 + (i * (levelWidth / coinCount)) + (Math.random() * 50),
                y: 100 + Math.random() * 150,
                collected: false
            });
        }

        // Add checkpoints
        const checkpointCount = Math.floor(levelWidth / CONFIG.GAME.checkpointDistance);
        for (let i = 1; i <= checkpointCount; i++) {
            traps.push({
                type: 'checkpoint',
                x: i * CONFIG.GAME.checkpointDistance,
                activated: false
            });
        }

        return traps;
    }

    createTrapElement(trap) {
        const el = document.createElement('div');
        el.className = 'trap';
        
        switch(trap.type) {
            case 'spike-trap':
                el.classList.add('spike-trap');
                el.innerHTML = '<div class="spike"></div>';
                el.style.left = trap.x + 'px';
                el.style.bottom = trap.hidden ? '-50px' : '80px';
                break;

            case 'laser-beam':
                el.classList.add('laser-beam');
                el.style.left = trap.x + 'px';
                if (trap.position === 'top') {
                    el.style.top = '0';
                    el.style.height = trap.height + 'px';
                } else {
                    el.style.bottom = '80px';
                    el.style.height = trap.height + 'px';
                }
                break;

            case 'saw-blade':
                el.classList.add('saw-blade');
                el.innerHTML = '<div class="saw"></div>';
                el.style.left = trap.x + 'px';
                trap.originalX = trap.x;
                break;

            case 'electric-field':
                el.classList.add('electric-field');
                el.style.left = trap.x + 'px';
                el.style.width = trap.width + 'px';
                // Create lightning bolts
                for (let i = 0; i < 3; i++) {
                    const lightning = document.createElement('div');
                    lightning.className = 'lightning';
                    lightning.style.setProperty('--pos', (i * 30 + 10) + 'px');
                    lightning.style.animationDelay = (i * 0.15) + 's';
                    el.appendChild(lightning);
                }
                break;

            case 'teleporter':
                el.classList.add('teleporter');
                el.style.left = trap.x + 'px';
                break;

            case 'moving-platform':
                el.classList.add('moving-platform');
                el.style.left = trap.x + 'px';
                el.style.bottom = trap.y + 'px';
                trap.originalX = trap.x;
                trap.direction = 1;
                break;

            case 'falling-platform':
                el.classList.add('falling-platform');
                el.style.left = trap.x + 'px';
                el.style.bottom = trap.y + 'px';
                break;

            case 'coin':
                el.classList.add('coin');
                el.style.left = trap.x + 'px';
                el.style.bottom = trap.y + 'px';
                break;

            case 'checkpoint':
                el.classList.add('checkpoint');
                el.classList.add('inactive');
                el.innerHTML = `
                    <div class="checkpoint-pole"></div>
                    <div class="checkpoint-flag"></div>
                `;
                el.style.left = trap.x + 'px';
                break;
        }

        trap.element = el;
        return el;
    }
}

class AchievementSystem {
    constructor() {
        this.achievements = {
            firstDeath: { unlocked: false, title: 'First Blood', desc: 'Die for the first time' },
            death10: { unlocked: false, title: 'Persistent', desc: 'Die 10 times' },
            death50: { unlocked: false, title: 'Determination', desc: 'Die 50 times' },
            speedrun: { unlocked: false, title: 'Speed Demon', desc: 'Complete a level in under 10 seconds' },
            coinCollector: { unlocked: false, title: 'Collector', desc: 'Collect 50 coins' },
            noDeathLevel: { unlocked: false, title: 'Flawless', desc: 'Complete a level without dying' },
            allCheckpoints: { unlocked: false, title: 'Checkpoint Master', desc: 'Activate all checkpoints in a level' }
        };
        this.element = document.getElementById('achievement');
    }

    unlock(key) {
        if (this.achievements[key] && !this.achievements[key].unlocked) {
            this.achievements[key].unlocked = true;
            this.show(this.achievements[key]);
            this.save();
        }
    }

    show(achievement) {
        document.getElementById('achievement-desc').textContent = 
            achievement.title + ': ' + achievement.desc;
        this.element.classList.add('show');
        
        setTimeout(() => {
            this.element.classList.remove('show');
        }, 3000);
    }

    save() {
        localStorage.setItem('unfair_achievements', JSON.stringify(this.achievements));
    }

    load() {
        const saved = localStorage.getItem('unfair_achievements');
        if (saved) {
            this.achievements = { ...this.achievements, ...JSON.parse(saved) };
        }
    }
}

class GameEngine {
    constructor(startLevel = 1) {
        // Core Systems
        this.particles = new ParticleSystem();
        this.trapGen = new TrapGenerator();
        this.achievements = new AchievementSystem();
        
        // Game State
        this.level = startLevel;
        this.deaths = parseInt(localStorage.getItem('unfair_deaths')) || 0;
        this.totalCoins = parseInt(localStorage.getItem('unfair_coins')) || 0;
        this.levelDeaths = 0;
        this.levelCoins = 0;
        this.levelStartTime = 0;
        this.currentCheckpoint = { x: 100, level: this.level };
        this.isPaused = false;
        this.isGrabbedByFlag = false;
        this.flagGrabProgress = 0;
        this.lastDodgeTime = 0;
        this.activeChatBubbles = [];
        this.cameraX = 0; // Camera position
        
        // Player State
        this.reset();
        
        // Elements
        this.player = document.getElementById('player');
        this.trapsLayer = document.getElementById('traps-layer');
        this.warningsLayer = document.getElementById('warnings-layer');
        
        // Init
        this.achievements.load();
        this.init();
    }

    reset() {
        this.posX = this.currentCheckpoint.x;
        this.posY = 0;
        this.velX = 0;
        this.velY = 0;
        this.isGrounded = true;
        this.isSliding = false;
        this.isDead = false;
        this.isFinished = false;
        this.isInvincible = false;
        this.keys = {};
        this.onPlatform = null;
    }

    init() {
        this.updateHUD();
        this.setupLevel(this.level);
        this.bindControls();
        this.showTutorial();
        this.startTimer();
        this.loop();
    }

    showTutorial() {
        if (!localStorage.getItem('unfair_tutorial_seen')) {
            document.getElementById('tutorial').style.display = 'block';
        }
    }

    closeTutorial() {
        document.getElementById('tutorial').style.display = 'none';
        localStorage.setItem('unfair_tutorial_seen', 'true');
    }

    bindControls() {
        // Keyboard
        window.addEventListener('keydown', (e) => {
            this.keys[e.code] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            this.keys[e.code] = false;
        });

        // Mobile Touch Controls
        document.querySelectorAll('.control-btn').forEach(btn => {
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const key = btn.dataset.key;
                this.keys[key] = true;
            });
            
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                const key = btn.dataset.key;
                this.keys[key] = false;
            });
        });
    }

    setupLevel(lvl) {
        this.reset();
        this.levelStartTime = Date.now();
        this.levelDeaths = 0;
        this.levelCoins = 0;
        this.isGrabbedByFlag = false;
        this.flagGrabProgress = 0;
        
        document.getElementById('lvl').textContent = lvl;
        
        // Clear previous level
        this.trapsLayer.innerHTML = '';
        this.warningsLayer.innerHTML = '';
        this.particles.clear();
        this.clearChatBubbles();
        
        // Show waifu on final level
        document.getElementById('waifu').style.display = (lvl === 10) ? 'block' : 'none';
        
        // Generate level
        this.currentTraps = this.trapGen.generateLevel(lvl);
        
        // Create trap elements
        this.currentTraps.forEach(trap => {
            const el = this.trapGen.createTrapElement(trap);
            this.trapsLayer.appendChild(el);
            
            // Setup random appearances
            if (trap.surprise && trap.surpriseTime) {
                // Hide initially
                if (trap.type === 'spike-trap') {
                    trap.element.style.bottom = '-50px';
                    trap.element.style.opacity = '0';
                } else if (trap.type === 'laser-beam') {
                    trap.element.style.opacity = '0';
                }
                
                // Schedule surprise appearance
                setTimeout(() => {
                    if (trap.element && !this.isDead) {
                        if (trap.type === 'spike-trap') {
                            trap.element.style.transition = 'all 0.2s ease-out';
                            trap.element.style.bottom = '80px';
                            trap.element.style.opacity = '1';
                            trap.element.style.animation = 'shake 0.5s';
                        } else if (trap.type === 'laser-beam') {
                            trap.active = true;
                            trap.element.style.transition = 'opacity 0.3s';
                            trap.element.style.opacity = '1';
                        }
                    }
                }, trap.surpriseTime);
            }
            
            // Setup blinking lasers
            if (trap.type === 'laser-beam' && trap.blinking) {
                setInterval(() => {
                    if (trap.element && !this.isDead) {
                        if (trap.active) {
                            trap.active = false;
                            trap.element.style.opacity = '0.2';
                        } else {
                            trap.active = true;
                            trap.element.style.opacity = '1';
                        }
                    }
                }, trap.blinkInterval);
            }
            
            // Create warning signs for dangerous traps
            if (['spike-trap', 'laser-beam', 'saw-blade'].includes(trap.type) && 
                !trap.hidden && Math.random() < 0.3) {
                this.createWarningSign(trap.x);
            }
        });

        // Create FINISH FLAG at the end
        this.createFinishFlag();

        this.updateMinimap();
    }

    createFinishFlag() {
        const flagX = CONFIG.GAME.levelWidth - 150;
        
        // Create BLACK HOLE effect
        const blackHole = document.createElement('div');
        blackHole.className = 'black-hole';
        blackHole.style.left = (flagX - 45) + 'px';
        blackHole.style.bottom = '105px';
        this.trapsLayer.appendChild(blackHole);
        
        // Create gravity field (outer glow)
        const gravityField = document.createElement('div');
        gravityField.className = 'gravity-field';
        gravityField.style.left = (flagX - 120) + 'px';
        gravityField.style.bottom = '30px';
        this.trapsLayer.appendChild(gravityField);
        
        // Create GLOWING FLAG
        const flag = document.createElement('div');
        flag.className = 'finish-flag';
        flag.id = 'finish-flag';
        flag.style.left = flagX + 'px';
        flag.innerHTML = `
            <div class="finish-pole"></div>
            <div class="finish-flag-cloth"></div>
            <div class="finish-flag-icon">ðŸš©</div>
        `;
        this.trapsLayer.appendChild(flag);
        
        // Create orbiting particles (energy swirls)
        for (let i = 0; i < 12; i++) {
            const particle = document.createElement('div');
            particle.className = 'gravity-particles';
            particle.style.left = (flagX + 30) + 'px';
            particle.style.bottom = '140px';
            particle.style.setProperty('--orbit-radius', (40 + (i % 3) * 20) + 'px');
            particle.style.setProperty('--orbit-duration', (1.5 + Math.random() * 1.5) + 's');
            particle.style.animationDelay = (i * 0.1) + 's';
            particle.style.background = i % 2 === 0 ? 'var(--primary)' : 'var(--secondary)';
            this.trapsLayer.appendChild(particle);
        }
        
        // Create light rays from flag
        for (let i = 0; i < 8; i++) {
            const ray = document.createElement('div');
            ray.style.position = 'absolute';
            ray.style.left = (flagX + 30) + 'px';
            ray.style.bottom = '140px';
            ray.style.width = '2px';
            ray.style.height = (50 + Math.random() * 50) + 'px';
            ray.style.background = 'linear-gradient(180deg, var(--primary), transparent)';
            ray.style.transformOrigin = 'bottom';
            ray.style.transform = `rotate(${i * 45}deg)`;
            ray.style.opacity = '0.6';
            ray.style.animation = `rayPulse ${1 + Math.random()}s ease-in-out infinite`;
            ray.style.animationDelay = (i * 0.1) + 's';
            ray.style.pointerEvents = 'none';
            ray.style.zIndex = '105';
            this.trapsLayer.appendChild(ray);
        }
        
        this.finishFlagX = flagX;
    }

    createWarningSign(x) {
        const warning = document.createElement('div');
        warning.className = 'warning-sign';
        warning.innerHTML = '<div class="warning-triangle"></div>';
        warning.style.left = x + 'px';
        this.warningsLayer.appendChild(warning);
    }

    update() {
        if (this.isDead || this.isFinished || this.isPaused) return;

        const prevX = this.posX;

        // Check flag gravity pull
        if (this.finishFlagX && !this.isGrabbedByFlag) {
            const distToFlag = this.finishFlagX - this.posX;
            const pullRadius = 200; // Increased from 150
            
            if (distToFlag > 0 && distToFlag < pullRadius) {
                // Gravity pull effect - STRONG PULL
                const pullStrength = (pullRadius - distToFlag) / pullRadius;
                const pullForce = pullStrength * 3.5; // Increased from 2
                this.posX += pullForce;
                
                // Visual feedback - particles flying towards flag
                if (Math.random() < 0.1) {
                    this.particles.createDustParticles(
                        this.posX + 15,
                        CONFIG.PHYSICS.groundY + Math.random() * 40
                    );
                }
                
                // Start grab sequence when very close
                if (distToFlag < 50) { // Increased from 40
                    this.isGrabbedByFlag = true;
                    this.flagGrabProgress = 0;
                    this.player.classList.add('climbing');
                    this.showFlagGrabMessage();
                }
            }
        }

        // Flag grab sequence
        if (this.isGrabbedByFlag) {
            this.flagGrabProgress += 0.02;
            this.posX = this.finishFlagX - 10;
            this.posY = -20 * this.flagGrabProgress;
            
            // Simulate struggling
            if (Math.random() < 0.3) {
                this.posX += (Math.random() - 0.5) * 2;
            }
            
            if (this.flagGrabProgress >= 2) {
                this.checkWin();
                return;
            }
            
            this.player.style.left = this.posX + 'px';
            this.player.style.bottom = (CONFIG.PHYSICS.groundY - this.posY) + 'px';
            
            // Update camera even during flag grab
            this.updateCamera();
            return;
        }

        // Input Handling
        let moving = false;
        
        if (this.keys['ArrowRight'] || this.keys['KeyD']) {
            const speed = this.isSliding ? CONFIG.PHYSICS.slideSpeed : CONFIG.PHYSICS.moveSpeed;
            this.posX += speed;
            this.player.classList.add('running');
            moving = true;
        }
        
        if (this.keys['ArrowLeft'] || this.keys['KeyA']) {
            const speed = this.isSliding ? CONFIG.PHYSICS.slideSpeed : CONFIG.PHYSICS.moveSpeed;
            this.posX -= speed;
            this.player.classList.add('running');
            moving = true;
        }

        if (!moving) {
            this.player.classList.remove('running');
        }

        // Jump
        if ((this.keys['ArrowUp'] || this.keys['KeyW'] || this.keys['Space']) && 
            (this.isGrounded || this.onPlatform)) {
            this.velY = CONFIG.PHYSICS.jumpForce;
            this.isGrounded = false;
            this.onPlatform = null;
            this.player.classList.add('jumping');
        } else {
            this.player.classList.remove('jumping');
        }

        // Slide
        if ((this.keys['ArrowDown'] || this.keys['KeyS']) && 
            (this.isGrounded || this.onPlatform)) {
            this.isSliding = true;
            this.player.classList.add('sliding');
        } else {
            this.isSliding = false;
            this.player.classList.remove('sliding');
        }

        // Physics
        this.velY += CONFIG.PHYSICS.gravity;
        this.posY += this.velY;

        // Platform collision
        let onAnyPlatform = false;
        this.currentTraps.forEach(trap => {
            if ((trap.type === 'moving-platform' || trap.type === 'falling-platform') && 
                trap.active) {
                const pRect = this.getPlayerRect();
                const tRect = trap.element.getBoundingClientRect();
                
                if (pRect.bottom >= tRect.top - 5 && 
                    pRect.bottom <= tRect.top + 10 &&
                    pRect.right > tRect.left && 
                    pRect.left < tRect.right &&
                    this.velY >= 0) {
                    this.posY = tRect.top - CONFIG.PHYSICS.groundY;
                    this.velY = 0;
                    this.isGrounded = true;
                    this.onPlatform = trap;
                    onAnyPlatform = true;

                    // Falling platform trigger
                    if (trap.type === 'falling-platform' && !trap.falling) {
                        trap.falling = true;
                        setTimeout(() => {
                            trap.element.classList.add('falling');
                            trap.active = false;
                        }, 500);
                    }
                }
            }
        });

        if (!onAnyPlatform) {
            this.onPlatform = null;
        }

        // Ground collision
        if (this.posY > 0) {
            this.posY = 0;
            this.velY = 0;
            this.isGrounded = true;
        }

        // Boundaries
        this.posX = Math.max(0, Math.min(this.posX, CONFIG.GAME.levelWidth));

        // Update DOM - Player stays at fixed position visually
        this.player.style.left = this.posX + 'px';
        this.player.style.bottom = (CONFIG.PHYSICS.groundY - this.posY) + 'px';

        // Effects
        if (moving && this.isGrounded && Math.random() < 0.3) {
            this.particles.createDustParticles(
                this.posX + 15,
                CONFIG.PHYSICS.groundY
            );
        }

        // CAMERA FOLLOW - Move the entire world instead of player
        this.updateCamera();
        
        // Update parallax
        this.updateParallax();
        
        // Update minimap
        this.updateMinimap();

        // Check interactions
        this.checkTraps();
        this.checkCollectibles();
        this.checkCheckpoints();
        this.checkTeleporters();
        this.checkWin();
        
        // Update moving traps
        this.updateMovingTraps();
    }

    updateCamera() {
        const stage = document.getElementById('stage');
        const stageWidth = stage.offsetWidth;
        const stageHeight = stage.offsetHeight;
        
        // Calculate camera position to center player
        // Player should be at 40% from left (slightly left of center for better view ahead)
        const targetCameraX = this.posX - (stageWidth * 0.4);
        
        // Smooth camera movement with lerp
        if (!this.cameraX) this.cameraX = 0;
        const smoothing = 0.1;
        this.cameraX += (targetCameraX - this.cameraX) * smoothing;
        
        // Clamp camera to level bounds
        const maxCameraX = CONFIG.GAME.levelWidth - stageWidth;
        this.cameraX = Math.max(0, Math.min(this.cameraX, maxCameraX));
        
        // Apply transform to move all game elements
        const layers = [
            this.trapsLayer,
            this.warningsLayer,
            document.getElementById('particles-layer'),
            document.getElementById('floor'),
            document.getElementById('waifu')
        ];
        
        layers.forEach(layer => {
            if (layer) {
                layer.style.transform = `translateX(${-this.cameraX}px)`;
            }
        });
        
        // Move player to appear centered
        const playerVisualX = this.posX - this.cameraX;
        this.player.style.left = playerVisualX + 'px';
        
        // Update chat bubbles positions
        this.activeChatBubbles.forEach(bubble => {
            if (bubble.dataset.worldX) {
                const worldX = parseFloat(bubble.dataset.worldX);
                bubble.style.left = (worldX - this.cameraX) + 'px';
            }
        });
    }

    getPlayerRect() {
        return {
            left: this.posX,
            right: this.posX + 35,
            top: CONFIG.PHYSICS.groundY - this.posY - (this.isSliding ? 25 : 60),
            bottom: CONFIG.PHYSICS.groundY - this.posY
        };
    }

    checkTraps() {
        if (this.isInvincible) return;

        const pRect = this.getPlayerRect();
        let nearMiss = false;

        this.currentTraps.forEach(trap => {
            if (!trap.element) return;

            // Popup spikes with RANDOM timing
            if (trap.type === 'spike-trap' && trap.popup && !trap.popped) {
                const distance = this.posX - trap.x;
                
                if (trap.appearRandom) {
                    // Random popup - appears when player is within random range
                    if (distance > -trap.appearDistance && distance < 50) {
                        setTimeout(() => {
                            if (trap.element && trap.popup) {
                                trap.element.style.transition = 'all 0.15s ease-out';
                                trap.element.style.bottom = '80px';
                                trap.element.style.opacity = '1';
                                trap.popup = false;
                                trap.popped = true;
                                
                                // Shake effect for drama
                                trap.element.style.transform = 'translateY(-10px)';
                                setTimeout(() => {
                                    if (trap.element) {
                                        trap.element.style.transform = 'translateY(0)';
                                    }
                                }, 150);
                            }
                        }, trap.appearDelay);
                    }
                } else {
                    // Normal popup at fixed distance
                    if (distance > -100 && !trap.popped) {
                        trap.element.style.bottom = '80px';
                        trap.element.style.opacity = '1';
                        trap.popup = false;
                        trap.popped = true;
                    }
                }
            }
            
            // Fakeout traps - look dangerous but harmless (for now...)
            if (trap.fakeout && trap.type === 'spike-trap' && !trap.revealed) {
                if (Math.abs(this.posX - trap.x) < 30) {
                    trap.revealed = true;
                    // Make it real after player passes (evil!)
                    setTimeout(() => {
                        trap.fakeout = false;
                        trap.active = true;
                    }, 1000);
                }
            }

            if (!trap.active) return;

            const tRect = trap.element.getBoundingClientRect();
            const stage = document.getElementById('stage').getBoundingClientRect();

            // Convert to stage-relative coordinates
            const trapBox = {
                left: tRect.left - stage.left,
                right: tRect.right - stage.left,
                top: tRect.top - stage.top,
                bottom: tRect.bottom - stage.top
            };

            const playerBox = {
                left: pRect.left,
                right: pRect.right,
                top: stage.height - pRect.top,
                bottom: stage.height - pRect.bottom
            };

            // Check near miss (within 20px)
            const distX = Math.min(
                Math.abs(playerBox.right - trapBox.left),
                Math.abs(playerBox.left - trapBox.right)
            );
            const distY = Math.min(
                Math.abs(playerBox.bottom - trapBox.top),
                Math.abs(playerBox.top - trapBox.bottom)
            );
            
            if ((distX < 20 || distY < 20) && 
                !(playerBox.right < trapBox.left || 
                  playerBox.left > trapBox.right || 
                  playerBox.bottom < trapBox.top || 
                  playerBox.top > trapBox.bottom)) {
                nearMiss = true;
            }

            // Collision detection
            if (!(playerBox.right < trapBox.left || 
                  playerBox.left > trapBox.right || 
                  playerBox.bottom < trapBox.top || 
                  playerBox.top > trapBox.bottom)) {
                
                // Special cases
                if (trap.type === 'laser-beam' && trap.position === 'top' && this.isSliding) {
                    nearMiss = true;
                    return; // Can slide under top lasers
                }

                if (trap.type === 'electric-field') {
                    // Random shock
                    if (Math.random() < 0.1) {
                        this.die(`ELECTROCUTED: ${Math.floor(Math.random() * 10000)} volts`);
                    }
                } else {
                    this.die(this.getDeathMessage(trap.type));
                }
            }
        });

        // Show dodge message on near miss
        if (nearMiss && Math.random() < 0.3) {
            this.showDodgeMessage();
        }
    }

    checkCollectibles() {
        const pRect = this.getPlayerRect();

        this.currentTraps.forEach(trap => {
            if (trap.type === 'coin' && !trap.collected && trap.element) {
                const tRect = trap.element.getBoundingClientRect();
                const stage = document.getElementById('stage').getBoundingClientRect();

                const trapX = tRect.left - stage.left + 15;
                const trapY = stage.height - (tRect.top - stage.top) - 15;

                const dist = Math.hypot(
                    (pRect.left + pRect.right) / 2 - trapX,
                    (pRect.top + pRect.bottom) / 2 - trapY
                );

                if (dist < 40) {
                    trap.collected = true;
                    trap.element.style.animation = 'coinFloat 0.3s ease-out forwards';
                    trap.element.style.transform = 'scale(1.5)';
                    trap.element.style.opacity = '0';
                    
                    this.levelCoins++;
                    this.totalCoins++;
                    this.updateHUD();

                    setTimeout(() => trap.element.remove(), 300);

                    // Achievement check
                    if (this.totalCoins >= 50) {
                        this.achievements.unlock('coinCollector');
                    }
                }
            }
        });
    }

    checkCheckpoints() {
        const pRect = this.getPlayerRect();

        this.currentTraps.forEach(trap => {
            if (trap.type === 'checkpoint' && !trap.activated && trap.element) {
                const tRect = trap.element.getBoundingClientRect();
                const stage = document.getElementById('stage').getBoundingClientRect();
                const trapX = tRect.left - stage.left;

                if (Math.abs((pRect.left + pRect.right) / 2 - trapX - 25) < 50) {
                    trap.activated = true;
                    trap.element.classList.remove('inactive');
                    this.currentCheckpoint = { x: trap.x - 50, level: this.level };
                    
                    // Flash effect
                    trap.element.style.animation = 'none';
                    setTimeout(() => {
                        trap.element.style.animation = '';
                    }, 10);
                }
            }
        });
    }

    checkTeleporters() {
        const pRect = this.getPlayerRect();

        this.currentTraps.forEach(trap => {
            if (trap.type === 'teleporter' && trap.active && trap.element) {
                const tRect = trap.element.getBoundingClientRect();
                const stage = document.getElementById('stage').getBoundingClientRect();

                const trapBox = {
                    left: tRect.left - stage.left,
                    right: tRect.right - stage.left,
                    top: tRect.top - stage.top,
                    bottom: tRect.bottom - stage.top
                };

                const playerBox = {
                    left: pRect.left,
                    right: pRect.right,
                    top: stage.height - pRect.top,
                    bottom: stage.height - pRect.bottom
                };

                if (!(playerBox.right < trapBox.left || 
                      playerBox.left > trapBox.right || 
                      playerBox.bottom < trapBox.top || 
                      playerBox.top > trapBox.bottom)) {
                    
                    // Teleport
                    this.posX = trap.targetX;
                    trap.active = false;
                    
                    // Visual effect
                    for (let i = 0; i < 15; i++) {
                        setTimeout(() => {
                            this.particles.createDustParticles(
                                this.posX + 15,
                                CONFIG.PHYSICS.groundY + Math.random() * 50
                            );
                        }, i * 20);
                    }
                }
            }
        });
    }

    updateMovingTraps() {
        this.currentTraps.forEach(trap => {
            if (trap.type === 'saw-blade' && trap.moving) {
                if (!trap.moveDir) trap.moveDir = 1;
                
                trap.x += trap.moveSpeed * trap.moveDir;
                
                if (Math.abs(trap.x - trap.originalX) > trap.moveRange) {
                    trap.moveDir *= -1;
                }
                
                // Random direction change for chaos!
                if (trap.randomReverse && Math.random() < 0.01) {
                    trap.moveDir *= -1;
                }
                
                trap.element.style.left = trap.x + 'px';
            }

            if (trap.type === 'moving-platform') {
                if (!trap.direction) trap.direction = 1;
                
                trap.x += trap.moveSpeed * trap.direction;
                
                if (Math.abs(trap.x - trap.originalX) > trap.moveRange) {
                    trap.direction *= -1;
                }
                
                trap.element.style.left = trap.x + 'px';

                // Move player with platform
                if (this.onPlatform === trap) {
                    this.posX += trap.moveSpeed * trap.direction;
                }
            }
        });
    }

    checkWin() {
        if (this.isGrabbedByFlag && this.flagGrabProgress >= 2) {
            this.isFinished = true;
            
            const levelTime = (Date.now() - this.levelStartTime) / 1000;
            
            // Save level stats
            const stats = {
                deaths: this.levelDeaths,
                coins: this.levelCoins,
                time: levelTime,
                completed: true
            };
            localStorage.setItem(`unfair_level_${this.level}_stats`, JSON.stringify(stats));
            
            // Unlock next level
            if (this.level >= gameManager.maxLevel && this.level < CONFIG.GAME.totalLevels) {
                gameManager.maxLevel = this.level + 1;
                localStorage.setItem('unfair_max_level', gameManager.maxLevel);
            }
            
            // Achievement checks
            if (levelTime < 10) {
                this.achievements.unlock('speedrun');
            }
            
            if (this.levelDeaths === 0 && this.level > 1) {
                this.achievements.unlock('noDeathLevel');
            }

            if (this.level < CONFIG.GAME.totalLevels) {
                this.showLevelComplete(levelTime);
            } else {
                this.showGameComplete(levelTime);
            }
        }
    }

    showChatBubble(message, type = 'dodge') {
        const bubble = document.createElement('div');
        bubble.className = 'chat-bubble';
        if (type === 'flag') {
            bubble.classList.add('flag-grab');
        }
        bubble.textContent = message;
        
        // Store world position for camera follow
        const worldX = this.posX - 20;
        bubble.dataset.worldX = worldX;
        
        // Position above player (will be updated by camera)
        bubble.style.left = worldX + 'px';
        bubble.style.bottom = (CONFIG.PHYSICS.groundY - this.posY + 80) + 'px';
        
        this.trapsLayer.appendChild(bubble);
        this.activeChatBubbles.push(bubble);
        
        // Remove after delay
        setTimeout(() => {
            bubble.style.opacity = '0';
            bubble.style.transform = 'translateY(-20px)';
            setTimeout(() => {
                if (bubble.parentNode) {
                    bubble.parentNode.removeChild(bubble);
                }
                const index = this.activeChatBubbles.indexOf(bubble);
                if (index > -1) {
                    this.activeChatBubbles.splice(index, 1);
                }
            }, 300);
        }, 2000);
    }

    showDodgeMessage() {
        const now = Date.now();
        if (now - this.lastDodgeTime < 1000) return; // Cooldown
        
        this.lastDodgeTime = now;
        const message = DODGE_MESSAGES[Math.floor(Math.random() * DODGE_MESSAGES.length)];
        this.showChatBubble(message, 'dodge');
    }

    showFlagGrabMessage() {
        const message = FLAG_GRAB_MESSAGES[Math.floor(Math.random() * FLAG_GRAB_MESSAGES.length)];
        this.showChatBubble(message, 'flag');
        
        // Show multiple messages while struggling
        setTimeout(() => {
            if (this.isGrabbedByFlag && this.flagGrabProgress < 1.5) {
                const msg = FLAG_GRAB_MESSAGES[Math.floor(Math.random() * FLAG_GRAB_MESSAGES.length)];
                this.showChatBubble(msg, 'flag');
            }
        }, 1000);
    }

    clearChatBubbles() {
        this.activeChatBubbles.forEach(bubble => {
            if (bubble.parentNode) {
                bubble.parentNode.removeChild(bubble);
            }
        });
        this.activeChatBubbles = [];
    }

    togglePause() {
        this.isPaused = !this.isPaused;
        const overlay = document.getElementById('pause-overlay');
        
        if (this.isPaused) {
            overlay.style.display = 'flex';
        } else {
            overlay.style.display = 'none';
        }
    }

    restartLevel() {
        this.isPaused = false;
        document.getElementById('pause-overlay').style.display = 'none';
        this.restart();
    }

    die(reason) {
        if (this.isDead || this.isInvincible) return;
        
        this.isDead = true;
        this.deaths++;
        this.levelDeaths++;
        localStorage.setItem('unfair_deaths', this.deaths);
        
        // Death explosion
        this.particles.createDeathExplosion(
            this.posX + 17,
            CONFIG.PHYSICS.groundY - this.posY + 30
        );
        
        // Hide player
        this.player.style.opacity = '0';
        
        // Achievement checks
        if (this.deaths === 1) {
            this.achievements.unlock('firstDeath');
        } else if (this.deaths === 10) {
            this.achievements.unlock('death10');
        } else if (this.deaths === 50) {
            this.achievements.unlock('death50');
        }

        setTimeout(() => {
            this.showDeathScreen(reason);
        }, 800);
    }

    getDeathMessage(trapType) {
        const messages = {
            'spike-trap': [
                'ðŸ’€ Báº¡n vá»«a thÃ nh "xiÃªn que ngÆ°á»i"!',
                'ðŸ—¡ï¸ Gai nhá»n: "ChÃ o má»«ng Ä‘áº¿n vá»›i cÃ¡i káº¿t nhá»n!"',
                'âš°ï¸ Cháº¿t kiá»ƒu "kebab" - khÃ´ng ngon Ä‘Ã¢u!',
                'ðŸ˜µ TrÃ´ng nhÆ° nhÃ­m rá»“i Ä‘áº¥y!',
                'ðŸŽ¯ Bullseye! NhÆ°ng mÃ ... RIP!',
                'ðŸ’” Gai: "Anh thÃ­ch em tá»« cÃ¡i nhÃ¬n Ä‘áº§u tiÃªn!"',
                'ðŸŒµ CÃ¢y xÆ°Æ¡ng rá»“ng cÅ©ng khÃ´ng nguy hiá»ƒm báº±ng cÃ¡i nÃ y!',
                'âš¡ Báº¡n nghÄ© mÃ¬nh lÃ  Superman Ã ? LOL!',
                'ðŸŽª Xiáº¿c Ä‘oÃ n gá»i, há» muá»‘n láº¥y láº¡i ká»¹ nÄƒng tung ngÆ°á»i!',
                'ðŸ¢ NÆ°á»›ng xiÃªn: Level failed edition!',
                'ðŸ˜± "á»i, gai!" - Last words famous!',
                'ðŸ’€ Spike: "Im not gonna hurt ya..." SIKE!',
                'ðŸ—¡ï¸ Gai nÃ y nhá»n hÆ¡n cáº£ lá»i boss chÃª!',
                'âš°ï¸ Cháº¿t kiá»ƒu "shish kebab" - Michelin 0 sao!',
                'ðŸ’€ "CÃ³ gÃ¬ Ä‘Ã¢u mÃ  sá»£" - Narrator: He was wrong!',
                'ðŸŽ¯ Gai: "Má»i anh vÃ o Ä‘Ã¢y!" - Báº¡n: "OK!" - RIP!'
            ],
            'laser-beam': [
                'ðŸ”¥ Bá»‹ nÆ°á»›ng báº±ng tia laser - well done!',
                'âš¡ Pew pew! Báº¡n tan thÃ nh khÃ³i rá»“i!',
                'ðŸŒŸ Ãnh sÃ¡ng cuá»‘i cÃ¹ng báº¡n tháº¥y... lÃ  laser!',
                'ðŸ’¥ ThÃ nh tro bá»¥i trong 0.1 giÃ¢y!',
                'ðŸ”´ Laser: "You shall not pass!" - Gandalf Ä‘Ã¢u rá»“i?',
                'âœ¨ Báº¡n vá»«a bá»‹ "photoshop" khá»i tháº¿ giá»›i!',
                'ðŸŽ† PhÃ¡o hoa ngÆ°á»i - khÃ´ng nÃªn thá»­ á»Ÿ nhÃ !',
                'ðŸ‘» Biáº¿n thÃ nh plasma... Khoa há»c!',
                'ðŸŒˆ Ãnh sÃ¡ng mÃ u Ä‘á» Ä‘áº¹p nhá»‰? á»i cháº¿t!',
                'âš°ï¸ Laser hair removal... toÃ n thÃ¢n. OOPS!',
                'â˜„ï¸ Vá»«a bá»‹ "delete" khá»i cuá»™c Ä‘á»i!',
                'ðŸ”¥ NÆ°á»›ng instant - khÃ´ng cáº§n lÃ² vi sÃ³ng!',
                'âš¡ Laser nÃ y máº¡nh hÆ¡n Ã¡nh máº¯t sáº¿p lÃºc deadline!',
                'ðŸ’€ Star Wars called: They want their lightsaber back!',
                'ðŸ”´ "Äá» Ä‘áº¹p nhá»‰?" - Famous last thoughts!',
                'âš°ï¸ BBQ ngÆ°á»i: KhÃ´ng khuyáº¿n khÃ­ch!'
            ],
            'saw-blade': [
                'âš™ï¸ LÆ°á»¡i cÆ°a: "Cáº¯t Ä‘á»©t hy vá»ng cá»§a báº¡n rá»“i!"',
                'ðŸ”ª ThÃ nh lÃ¡t má»ng... khÃ´ng pháº£i salami!',
                'ðŸ’€ Nghe tiáº¿ng "bzzzz"... Ä‘Ã£ muá»™n rá»“i!',
                'ðŸŽª áº¢o thuáº­t cáº¯t ngÆ°á»i - nhÆ°ng khÃ´ng ghÃ©p láº¡i Ä‘Æ°á»£c!',
                'ðŸ˜± Pizza cutter nhÆ°ng size XXL!',
                'âš¡ Ninja blade khÃ´ng ká»‹p nÃ©!',
                'ðŸŒ€ Xoay trÃ²n Ä‘á»i ngÆ°á»i... theo nghÄ©a Ä‘en!',
                'ðŸŽ¡ VÃ²ng quay tá»­ tháº§n - vÃ© má»™t chiá»u!',
                'ðŸ’” CÆ°a: "Chia tay nhÃ©!" - QuÃ¡ Ä‘au!',
                'ðŸ­ NhÃ  mÃ¡y cháº¿ biáº¿n... game over!',
                'âš™ï¸ LÆ°á»¡i cÆ°a khÃ´ng hiá»ƒu táº¡i sao báº¡n láº¡i nháº£y vÃ o!',
                'ðŸ˜µ "Buzz saw my way out" - KhÃ´ng Ä‘Æ°á»£c Ä‘Ã¢u báº¡n Æ¡i!',
                'ðŸ”ª CÆ°a nÃ y cáº¯t nhanh hÆ¡n cáº£ boss cáº¯t bonus!',
                'âš™ï¸ Saw: "I want to play a game" - Báº¡n thua rá»“i!',
                'ðŸ’€ Minced meat: Human edition!',
                'ðŸŒ€ VÃ²ng xoay Ä‘á»‹nh má»‡nh - KhÃ´ng may máº¯n!'
            ],
            'electric-field': [
                'âš¡ Giáº­t Ä‘iá»‡n: 220V niá»m vui... 440V cÃ¡i cháº¿t!',
                'ðŸ’¥ Bá»‹ sá»‘c... kiá»ƒu cháº¿t luÃ´n!',
                'ðŸ”Œ Cáº¯m nháº§m á»• Ä‘iá»‡n Ä‘á»i ngÆ°á»i!',
                'âš¡ Pikachu dÃ¹ng Thunder Shock! Super effective!',
                'ðŸ˜µ TÃ³c dá»±ng Ä‘á»©ng... vÃ  máº¥t máº¡ng!',
                'ðŸŒ©ï¸ Sáº¥m sÃ©t ná»™i bá»™ - khÃ´ng báº£o hiá»ƒm!',
                'ðŸ’€ Tá»« ngÆ°á»i thÃ nh... ngÆ°á»i Ä‘iá»‡n!',
                'âš¡ Tesla gá»i, muá»‘n nghiÃªn cá»©u case cá»§a báº¡n!',
                'ðŸ”‹ Battery 100%... cá»§a tháº§n cháº¿t!',
                'ðŸ’¡ SÃ¡ng lÃªn rá»“i táº¯t... luÃ´n!',
                'âš¡ Äiá»‡n giáº­t máº¡nh hÆ¡n cáº£ deadline!',
                'ðŸ˜± "Shocking!" - In every sense!',
                'ðŸ”Œ CÃº Ä‘iá»‡n giáº­t máº¡nh hÆ¡n email sáº¿p lÃºc 11h Ä‘Ãªm!',
                'âš¡ Äiá»‡n lá»±c VN: "ChÆ°a Ä‘Ã³ng tiá»n Ã ?"',
                'ðŸ’¥ Tá»« thá»‹t ngÆ°á»i thÃ nh... thá»‹t nÆ°á»›ng Ä‘iá»‡n!',
                'âš¡ AC/DC cÅ©ng khÃ´ng bay Ä‘Æ°á»£c cao tháº¿ nÃ y!'
            ],
            'moving-platform': [
                'ðŸš‚ TÃ u khÃ´ng chá»... vÃ  báº¡n rÆ¡i!',
                'â¬‡ï¸ RÆ¡i xuá»‘ng vá»±c: "Wheeeee... oh no!"',
                'ðŸŽ¢ Roller coaster nhÆ°ng khÃ´ng vui!',
                'ðŸ’€ Platform: "Táº¡m biá»‡t!" - Báº¡n: "Äá»£i tÃ´i!" *splat*',
                'ðŸƒ Cháº¡y khÃ´ng ká»‹p = Game over!',
                'ðŸ˜± Äá»™ cao nÃ y... khÃ´ng cáº§n dÃ¹!',
                'âš°ï¸ RÆ¡i tá»± do... vÃ  tá»± cháº¿t!',
                'ðŸŽª Nháº£y xa Olympic... xuá»‘ng Ä‘á»‹a ngá»¥c!',
                'ðŸ’” Platform friendzone: "MÃ¬nh khÃ´ng há»£p Ä‘Ã¢u!"',
                'ðŸŒŠ KhÃ´ng cÃ³ nÆ°á»›c bÃªn dÆ°á»›i Ä‘Ã¢u báº¡n Æ¡i!',
                'ðŸš‚ Bá»¥c cháº¡y nhanh hÆ¡n cáº£ thá»i gian lÃªn lÆ°Æ¡ng!',
                'â¬‡ï¸ Gravity: "Let me introduce myself!"',
                'ðŸ’€ "Bá»¥c Ä‘á»£i tÃ´i!" - Bá»¥c: "KhÃ´ng!"',
                'ðŸŽ¢ Báº¡n yÃªu cáº§u: Vui váº». Báº¡n nháº­n Ä‘Æ°á»£c: Cháº¿t!',
                'âš°ï¸ Free fall - khÃ´ng free Ä‘Ã¢u nhÃ©!',
                'ðŸ˜± RÆ¡i nhanh hÆ¡n cáº£ career cá»§a ngÆ°á»i OT khÃ´ng lÆ°Æ¡ng!'
            ],
            'falling-platform': [
                'ðŸ“‰ SÃ n sáº­p: "Surprise motherfucker!"',
                'ðŸ˜¨ Äá»©ng lÃ¢u quÃ¡ = cháº¿t!',
                'ðŸ—ï¸ Cháº¥t lÆ°á»£ng sÃ n: 0 sao - khÃ´ng nÃªn tin!',
                'ðŸ’€ Ká»¹ sÆ° xÃ¢y sÃ n bá»‹ Ä‘uá»•i viá»‡c rá»“i!',
                'âš°ï¸ Sáº­p nhÆ°... hy vá»ng cá»§a báº¡n!',
                'ðŸŽª Magic trick: SÃ n biáº¿n máº¥t!',
                'ðŸ˜± "SÃ n Æ¡i Ä‘á»«ng bá» tÃ´i!" - Too late!',
                'ðŸ’” Betrayed by the floor!',
                'ðŸŒªï¸ Bay xuá»‘ng Ä‘á»‹a ngá»¥c express!',
                'âš¡ Trá»ng lá»±c: "Let me introduce myself!"',
                'ðŸ“‰ SÃ n sáº­p nhanh hÆ¡n giÃ¡ Bitcoin!',
                'ðŸ—ï¸ XÃ¢y dá»±ng: "Cháº¥t lÆ°á»£ng cao!" - Narrator: KhÃ´ng!',
                'ðŸ’€ SÃ n pháº£n bá»™i nhÆ° Ä‘á»“ng nghiá»‡p!',
                'ðŸ˜± Trust issues with platforms now!',
                'âš°ï¸ Sáº­p nhÆ° morale sau meeting thá»© 5 trong ngÃ y!'
            ],
            'general': [
                'ðŸ’€ Báº¡n cháº¿t rá»“i... Again!',
                'ðŸ˜µ Game Over - Skill issue detected!',
                'âš°ï¸ Press F to pay respect... to yourself!',
                'ðŸ’” Thua rá»“i báº¡n Æ¡i!',
                'ðŸ˜± Cháº¿t chÆ°a? Cháº¿t rá»“i!',
                'ðŸŽ® Noob detected! System shutting down...',
                'ðŸ’€ "Ez game" - Narrator: It was not ez',
                'ðŸ˜­ KhÃ³c Ä‘i, rá»“i chÆ¡i láº¡i!',
                'âš¡ Reflexes: 404 Not Found',
                'ðŸ† Achievement: Professional Die-er!',
                'ðŸ’¥ Boom! Headshot... from yourself!',
                'ðŸ˜‚ HAHAHA... *ahem* Thá»­ láº¡i Ä‘i!',
                'ðŸŽ¯ Mission Failed... We\'ll get \'em next time!',
                'ðŸ’€ Cháº¿t nhiá»u váº­y khÃ´ng má»‡t Ã ?',
                'âš°ï¸ RIP - Rest In... Play again!',
                'ðŸ˜µ LÆ°Æ¡ng 8tr nhÆ°ng skill 80k!',
                'ðŸ’€ Boss há»i: "Viá»‡c xong chÆ°a?" - Báº¡n: *cháº¿t*',
                'âš°ï¸ Cháº¿t nhiá»u hÆ¡n sá»‘ email chÆ°a Ä‘á»c!',
                'ðŸ˜± Plot twist: Báº¡n má»›i lÃ  báº«y!',
                'ðŸŽ® Game: Hard. Báº¡n: Harder to survive!',
                'ðŸ’€ Darwin Award nominee detected!',
                'âš¡ Speed: 100. Skill: 0. Death: 1.',
                'ðŸ˜­ "I can do this!" - Narrator: He could not.',
                'ðŸ’” Cháº¿t kiá»ƒu "wtf just happened"!',
                'ðŸŽª Performance review: 0/10 - Would not hire!',
                'ðŸ’€ Cháº¿t nhiá»u hÆ¡n láº§n boss nÃ³i "cá»‘ gáº¯ng"!',
                'ðŸ˜µ Skills level: Intern. Traps level: CEO!',
                'âš°ï¸ Thá»­ viá»‡c tháº¥t báº¡i - khÃ´ng qua vÃ²ng 1!',
                'ðŸŽ¯ KPI thÃ¡ng nÃ y: 100 deaths achieved!',
                'ðŸ’€ "Láº§n nÃ y cháº¯c Ä‘Æ°á»£c!" - Narrator: Nope!'
            ]
        };

        const options = messages[trapType] || messages['general'];
        return options[Math.floor(Math.random() * options.length)];
    }

    makeInvincible() {
        this.isInvincible = true;
        this.player.classList.add('invincible');
        
        setTimeout(() => {
            this.isInvincible = false;
            this.player.classList.remove('invincible');
        }, CONFIG.GAME.invincibilityTime);
    }

    showDeathScreen(reason) {
        document.getElementById('msg-title').textContent = 'SYNC LOST';
        document.getElementById('msg-title').style.color = 'var(--danger)';
        document.getElementById('msg-desc').textContent = reason;
        
        const stats = `
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">LEVEL DEATHS</div>
                    <div class="stat-value">${this.levelDeaths}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">TOTAL DEATHS</div>
                    <div class="stat-value">${this.deaths}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">COINS</div>
                    <div class="stat-value">${this.levelCoins}</div>
                </div>
            </div>
        `;
        document.getElementById('stats-container').innerHTML = stats;
        
        document.getElementById('msg-overlay').style.display = 'flex';
    }

    showLevelComplete(time) {
        document.getElementById('msg-title').textContent = 'SECTOR CLEARED';
        document.getElementById('msg-title').style.color = 'var(--success)';
        document.getElementById('msg-desc').textContent = 
            `âœ… ${LEVEL_NAMES[this.level-1]} hoÃ n thÃ nh!\nChuyá»ƒn sang Sector ${this.level + 1}: ${LEVEL_NAMES[this.level]}`;
        
        const stats = `
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">TIME</div>
                    <div class="stat-value">${time.toFixed(1)}s</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">DEATHS</div>
                    <div class="stat-value">${this.levelDeaths}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">COINS</div>
                    <div class="stat-value">${this.levelCoins}</div>
                </div>
            </div>
        `;
        document.getElementById('stats-container').innerHTML = stats;
        document.getElementById('next-btn').style.display = 'inline-block';
        
        document.getElementById('msg-overlay').style.display = 'flex';
    }

    showGameComplete(time) {
        document.getElementById('msg-title').textContent = 'ðŸ† HOÃ€N THÃ€NH TOÃ€N Bá»˜!';
        document.getElementById('msg-title').style.color = 'var(--waifu)';
        document.getElementById('msg-desc').textContent = 
            'ðŸŽ‰ ChÃºc má»«ng! Báº¡n Ä‘Ã£ vÆ°á»£t qua táº¥t cáº£ 10 mÃ n!\nLÆ°Æ¡ng 8tr nhÆ°ng skills triá»‡u Ä‘Ã´! ðŸ’°';
        
        const stats = `
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-label">TOTAL DEATHS</div>
                    <div class="stat-value">${this.deaths}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">TOTAL COINS</div>
                    <div class="stat-value">${this.totalCoins}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">RANK</div>
                    <div class="stat-value">${this.getRank()}</div>
                </div>
            </div>
        `;
        document.getElementById('stats-container').innerHTML = stats;
        document.getElementById('next-btn').style.display = 'none';
        
        document.getElementById('msg-overlay').style.display = 'flex';
    }

    getRank() {
        if (this.deaths < 20) return 'ðŸ† S';
        if (this.deaths < 50) return 'ðŸ¥‡ A';
        if (this.deaths < 100) return 'ðŸ¥ˆ B';
        if (this.deaths < 200) return 'ðŸ¥‰ C';
        return 'ðŸ’€ D';
    }

    restart() {
        this.player.style.opacity = '1';
        this.isDead = false;
        this.isFinished = false;
        this.currentCheckpoint = { x: 100, level: this.level };
        this.setupLevel(this.level);
        this.makeInvincible();
        this.updateHUD();
        document.getElementById('msg-overlay').style.display = 'none';
    }

    nextLevel() {
        if (this.level < CONFIG.GAME.totalLevels) {
            this.level++;
            this.currentCheckpoint = { x: 100, level: this.level };
            this.player.style.opacity = '1';
            this.isDead = false;
            this.isFinished = false;
            this.setupLevel(this.level);
            this.updateHUD();
            document.getElementById('msg-overlay').style.display = 'none';
        }
    }

    updateHUD() {
        document.getElementById('deaths').textContent = this.deaths;
        document.getElementById('coins').textContent = this.totalCoins;
        
        const progress = (this.posX / CONFIG.GAME.levelWidth) * 100;
        document.getElementById('progress').style.width = Math.min(progress, 100) + '%';
    }

    startTimer() {
        this.timerStart = Date.now();
        setInterval(() => {
            if (!this.isDead && !this.isFinished) {
                const elapsed = Math.floor((Date.now() - this.timerStart) / 1000);
                document.getElementById('timer').textContent = this.formatTime(elapsed);
            }
        }, 1000);
    }

    formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    updateParallax() {
        // Use camera position for parallax, not player position
        const farOffset = this.cameraX * CONFIG.VISUAL.parallaxFarSpeed;
        const nearOffset = this.cameraX * CONFIG.VISUAL.parallaxNearSpeed;
        
        document.getElementById('mountains-far').style.transform = 
            `translateX(-${farOffset}px)`;
        document.getElementById('mountains-near').style.transform = 
            `translateX(-${nearOffset}px)`;
    }

    updateMinimap() {
        const minimapPlayer = document.getElementById('minimap-player');
        const progress = (this.posX / CONFIG.GAME.levelWidth) * 180;
        minimapPlayer.style.left = (10 + progress) + 'px';
    }

    loop() {
        this.update();
        requestAnimationFrame(() => this.loop());
    }
}

// Initialize Game Systems
const gameManager = new GameManager();
const loadingManager = new LoadingManager();

// Lock screen orientation to landscape on mobile
function lockOrientation() {
    if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock('landscape').catch(err => {
            console.log('Orientation lock not supported:', err);
        });
    } else if (screen.lockOrientation) {
        screen.lockOrientation('landscape');
    } else if (screen.mozLockOrientation) {
        screen.mozLockOrientation('landscape');
    } else if (screen.msLockOrientation) {
        screen.msLockOrientation('landscape');
    }
}

// Prevent double-tap zoom on iOS
let lastTouchEnd = 0;
document.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) {
        e.preventDefault();
    }
    lastTouchEnd = now;
}, { passive: false });

// Prevent pinch zoom
document.addEventListener('gesturestart', (e) => {
    e.preventDefault();
});

document.addEventListener('gesturechange', (e) => {
    e.preventDefault();
});

document.addEventListener('gestureend', (e) => {
    e.preventDefault();
});

// Prevent zoom with wheel/trackpad
document.addEventListener('wheel', (e) => {
    if (e.ctrlKey) {
        e.preventDefault();
    }
}, { passive: false });

// Handle fullscreen on mobile
function requestFullscreen() {
    const elem = document.documentElement;
    if (elem.requestFullscreen) {
        elem.requestFullscreen();
    } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen();
    } else if (elem.mozRequestFullScreen) {
        elem.mozRequestFullScreen();
    } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen();
    }
}

// Auto-enter fullscreen on mobile when game starts
function enableMobileOptimizations() {
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (isMobile) {
        // Lock orientation
        lockOrientation();
        
        // Request fullscreen on first user interaction
        document.addEventListener('touchstart', () => {
            requestFullscreen();
            lockOrientation();
        }, { once: true });
        
        // Prevent iOS bounce/scroll
        document.body.style.position = 'fixed';
        document.body.style.overflow = 'hidden';
        document.body.style.width = '100%';
        document.body.style.height = '100%';
    }
}

// Start loading on page load
window.addEventListener('DOMContentLoaded', () => {
    enableMobileOptimizations();
    loadingManager.start();
});

// Prevent context menu on mobile
document.addEventListener('contextmenu', (e) => e.preventDefault());

// Disable pull-to-refresh on mobile
document.body.addEventListener('touchmove', (e) => {
    if (e.touches.length > 1) {
        e.preventDefault();
    }
}, { passive: false });

// Prevent accidental page navigation
window.addEventListener('beforeunload', (e) => {
    if (window.engine && !engine.isDead && !engine.isFinished) {
        e.preventDefault();
        e.returnValue = 'Game Ä‘ang chÆ¡i dá»Ÿ! Cháº¯c cháº¯n muá»‘n thoÃ¡t?';
        return e.returnValue;
    }
});

</script>
</body>
</html>
